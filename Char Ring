Base_Stats = {'STR','DEX','CON','INT','WIS','CHA'}

objectOffsetList = { -- Objects different than 3DTexts

--[[
Format for each line:
[Name] = {
            x position of the object, z position of the object,
            ['type'] = 'the kind of object to be spawned', ['height'] = the y position of the object,
            ['rot'] = {x rotation, y rotation, z rotation}, ['scale'] = the size of the object,
            ['name'] = 'the visible display name of the spawned object',
            (optional)['tab'] = 'the tab table in the tabOffsetList you want this item to belong to -defaults to nil-',
            (optional)['scrollbar'] = true if the object is a notecard and you would like it to have scrolling capability -defaults to false-
         }
--]]

    ['HP']        = { 2.161939,-4.81705,     ['type'] = 'Counter',  ['height'] = 0.4229977, ['rotation'] = {-90,0,0}, ['scale'] = 1.05,  ['name'] = 'Health'},
    ['Note1']     = { -2.5398102,-3.9832565, ['type'] = 'Notecard', ['height'] = 1.04,      ['rotation'] = {-90,0,0}, ['scale'] = 0.65,  ['name'] = 'Normal Attacks',                         ['tab'] = 'Tab_1'},
    ['Note2']     = { -7.2604314,-3.9832565, ['type'] = 'Notecard', ['height'] = 1.04,      ['rotation'] = {-90,0,0}, ['scale'] = 0.65,  ['name'] = 'Special Attacks',                        ['tab'] = 'Tab_1'},
    ['Note3']     = { -4.9058342,5.02206,    ['type'] = 'Notecard', ['height'] = 1.014,     ['rotation'] = {-90,0,0}, ['scale'] = 1.175, ['name'] = 'Companions',                             ['tab'] = 'Tab_1'},
    ['Note4']     = { -2.5398102,-3.9832565, ['type'] = 'Notecard', ['height'] = 1.04,      ['rotation'] = {-90,0,0}, ['scale'] = 0.65,  ['name'] = 'Spellbook',        ['scrollbar'] = true, ['tab'] = 'Tab_2'},
    ['Note5']     = { -7.2604314,-3.9832565, ['type'] = 'Notecard', ['height'] = 1.04,      ['rotation'] = {-90,0,0}, ['scale'] = 0.65,  ['name'] = 'Prepared Spells',  ['scrollbar'] = true, ['tab'] = 'Tab_2'},
    ['Note6']     = { -2.5398102,-1.02831,   ['type'] = 'Notecard', ['height'] = 1.04,      ['rotation'] = {-90,0,0}, ['scale'] = 0.65,  ['name'] = 'Magic Items',      ['scrollbar'] = true, ['tab'] = 'Tab_2'},
    ['Note7']     = { -2.5398102,-3.9832565, ['type'] = 'Notecard', ['height'] = 1.04,      ['rotation'] = {-90,0,0}, ['scale'] = 0.65,  ['name'] = 'Traits/Flaws',                           ['tab'] = 'Tab_3'},
    ['Note8']     = { -7.2604314,-3.9832565, ['type'] = 'Notecard', ['height'] = 1.04,      ['rotation'] = {-90,0,0}, ['scale'] = 0.65,  ['name'] = 'Appearance',                             ['tab'] = 'Tab_3'},
    ['Note9']     = { -7.2604314,-1.02831,   ['type'] = 'Notecard', ['height'] = 1.04,      ['rotation'] = {-90,0,0}, ['scale'] = 0.65,  ['name'] = 'Bonds',                                  ['tab'] = 'Tab_3'},
    ['Note10']    = { -4.9058342,5.02206,    ['type'] = 'Notecard', ['height'] = 1.014,     ['rotation'] = {-90,0,0}, ['scale'] = 1.175, ['name'] = 'Backstory',        ['scrollbar'] = true, ['tab'] = 'Tab_3'},
    ['Note11']    = { -2.5398102,-3.9832565, ['type'] = 'Notecard', ['height'] = 1.04,      ['rotation'] = {-90,0,0}, ['scale'] = 0.65,  ['name'] = 'Race/Class Feats', ['scrollbar'] = true, ['tab'] = 'Tab_4'},
    ['Note12']    = { -7.2604314,-3.9832565, ['type'] = 'Notecard', ['height'] = 1.04,      ['rotation'] = {-90,0,0}, ['scale'] = 0.65,  ['name'] = 'Additional Feats', ['scrollbar'] = true, ['tab'] = 'Tab_4'},
    ['Note13']    = { -2.5398102,-1.02831,   ['type'] = 'Notecard', ['height'] = 1.04,      ['rotation'] = {-90,0,0}, ['scale'] = 0.65,  ['name'] = 'Languages',                              ['tab'] = 'Tab_4'},
    ['Note14']    = { -4.9058342,5.02206,    ['type'] = 'Notecard', ['height'] = 1.014,     ['rotation'] = {-90,0,0}, ['scale'] = 1.175, ['name'] = 'Personal Journal', ['scrollbar'] = true, ['tab'] = 'Tab_4'},
    ['Equipment'] = { 6.476904,-0.0266,      ['type'] = 'Notecard', ['height'] = 1.031,     ['rotation'] = {-90,0,0}, ['scale'] = 0.775, ['name'] = 'Equipment',        ['scrollbar'] = true},
    ['Inventory'] = { 4.994779,4.361943,     ['type'] = 'Notecard', ['height'] = 1.023388,  ['rotation'] = {-90,0,0}, ['scale'] = 0.925, ['name'] = 'Inventory'}
}

incrementalOffsetList = { -- Text Tools that will spawn modifiers to act like counters - for numbers

   --[[
   Format for each line:
   [Name] = {
                x position of Text Tool, z position of Text Tool, ['size'] = font size,
                ['gap'] = { space between x axis of +/- buttons, space between z axis of +/- buttons },
                ['mod'] = { x position of the center of +/- buttons relative to the Text Tool, z position of the center of +/- buttons relative to the Text Tool }
                (optional)['modSize'] = size of the buttons -defaults to 200-, (optional)['color'] = color of the Text Tool -defaults to 'Grey'-,
                (optional)['alwaysVisible'] = false to only show buttons when in "Edit Mode" or true to always display buttons -defaults to false-,
                (optional)['triggerUpdate'] = false to prevent the button(s) from calling calculateCharacterSheetValues() when modified or true to make the button(s) call the function when modified -defaults to false-,
                (optional)['tab'] = 'the tab table in the tabOffsetList you want this item to belong to -defaults to nil-'
            }
   --]]

    ['Speed']              = { 2.074633,-0.23846, ['size'] = 36, ['gap'] = {0.6,0},  ['mod'] = {0,0.3} },
    ['Initiative']         = { 2.074633,-1.3,     ['size'] = 40, ['gap'] = {0.6,0},  ['mod'] = {0,0.3} },
    ['Inspiration']        = { 12.78864,-5.92592, ['size'] = 40, ['gap'] = {0,0.15}, ['mod'] = {-3.06,0.3}, ['modSize']=150 },
    ['Proficiency_Bonus']  = { 12.71865,-4.97593, ['size'] = 40, ['gap'] = {0,0.15}, ['mod'] = {-3,0.3},    ['modSize']=150, ['triggerUpdate'] = true},
    ['Spell_Save_DC']      = { 7.052309,-3.18593, ['size'] = 40, ['gap'] = {0.52,0}, ['mod'] = {0,0.26} },
    ['Spell_Attack_Bonus'] = { 5.488634,-3.18593, ['size'] = 40, ['gap'] = {0.52,0}, ['mod'] = {0,0.26} },
    ['Max_HP']             = { 1.454685,-3.27593, ['size'] = 64, ['gap'] = {0.6,0},  ['mod'] = {0,0.5} },
    ['Max_Hit_Dice']       = { 3.6,-3.47588,      ['size'] = 30, ['gap'] = {0,0.15}, ['mod'] = {0.47,0.27}, ['modSize'] = 150 },
    ['Current_Hit_Dice']   = { 3.488621,-3.07589, ['size'] = 72, ['gap'] = {0.6,0},  ['mod'] = {0.02,0.9} },
    ['Armor_Class']        = { 4.790911,-5.37751, ['size'] = 72, ['gap'] = {0.85,0}, ['mod'] = {0,0},       ['modSize'] = 180, ['color'] = 'Silver'},
    ['STR']                = { 14.88861,-6.01784, ['size'] = 72, ['gap'] = {0.85,0}, ['mod'] = {0,1.8},     ['modSize'] = 250, ['color'] = 'Red',    ['triggerUpdate'] = true},
    ['DEX']                = { 14.88863,-3.52217, ['size'] = 72, ['gap'] = {0.85,0}, ['mod'] = {0,1.8},     ['modSize'] = 250, ['color'] = 'Green',  ['triggerUpdate'] = true},
    ['CON']                = { 14.88863,-1.04589, ['size'] = 72, ['gap'] = {0.85,0}, ['mod'] = {0,1.8},     ['modSize'] = 250, ['color'] = 'Black',  ['triggerUpdate'] = true},
    ['INT']                = { 14.88863,1.44407,  ['size'] = 72, ['gap'] = {0.85,0}, ['mod'] = {0,1.8},     ['modSize'] = 250, ['color'] = 'Blue',   ['triggerUpdate'] = true},
    ['WIS']                = { 14.88863,3.934117, ['size'] = 72, ['gap'] = {0.85,0}, ['mod'] = {0,1.8},     ['modSize'] = 250, ['color'] = 'Pink',   ['triggerUpdate'] = true},
    ['CHA']                = { 14.88863,6.424077, ['size'] = 72, ['gap'] = {0.85,0}, ['mod'] = {0,1.8},     ['modSize'] = 250, ['color'] = 'Yellow', ['triggerUpdate'] = true},
    ['Copper']             = { 8.488632,6.974126, ['size'] = 36, ['gap'] = {0.4,0},  ['mod'] = {0,0.8}, ['color'] = 'Copper',  ['alwaysVisible'] = true},
    ['Silver']             = { 6.688649,6.974126, ['size'] = 36, ['gap'] = {0.4,0},  ['mod'] = {0,0.8}, ['color'] = 'Silver',  ['alwaysVisible'] = true},
    ['Electrum']           = { 4.868639,6.974126, ['size'] = 36, ['gap'] = {0.4,0},  ['mod'] = {0,0.8}, ['color'] = 'Electrum',['alwaysVisible'] = true},
    ['Gold']               = { 3.02866,6.97431,   ['size'] = 36, ['gap'] = {0.4,0},  ['mod'] = {0,0.8}, ['color'] = 'Gold',    ['alwaysVisible'] = true},
    ['Platinum']           = { 1.258625,6.974126, ['size'] = 36, ['gap'] = {0.4,0},  ['mod'] = {0,0.8}, ['color'] = 'Platinum',['alwaysVisible'] = true}
}

toggleOffsetList = { -- Text Tools that will spawn buttons which change the value of the Text Tool

    --[[
    Format for each line:
    [Name] = {
                 x position of Text Tool, z position of Text Tool, ['size'] = font size,
                 ['set'] = {the different toggle displays},
                 ['mod'] = { x position of the center of the button relative to the Text Tool, z position of the center of the button relative to the Text Tool }
                 (optional)['modSize'] = size of the button -defaults to 200-, (optional)['color'] = color of the Text Tool -defaults to 'Grey'-,
                 (optional)['alwaysVisible'] = 0 to only show buttons when in "Edit Mode" or 1 to always display buttons -defaults to 0-,
                 (optional)['triggerUpdate'] = false to prevent the button(s) from calling calculateCharacterSheetValues() when modified or true to make the button(s) call the function when modified -defaults to false-
                 (optional)['tab'] = 'the tab table in the tabOffsetList you want this item to belong to -defaults to nil-'
             }
    --]]

    ['Max_Hit_Dice_Type']     = { 3,-3.47588,        ['size'] = 30, ['set'] = {'d4','d6','d8','d12'},                        ['mod'] = {0,0.22}, ['modSize'] = 300},
    ['Vision']                = { 2.074633,0.97407,  ['size'] = 24, ['set'] = {'Blinded','Normal','Darkvision','Truesight'}, ['mod'] = {0,0.22}, ['modSize'] = 400},
    ['Spell_Casting_Ability'] = { 8.558649,-3.18593, ['size'] = 40, ['set'] = {'STR','DEX','CON','INT','WIS','CHA'},         ['mod'] = {0,0.25}, ['modSize'] = 400}
}

checkboxOffsetList = { -- Text Tools that contain lists of individual items with checkboxes

    --[[
    Format for each line:
    [Name] = {
                 x position of Text Tool, z position of Text Tool, ['size'] = font size,
                 (optional)['rotation'] = {x rotation, y rotation, z rotation} used primarily to create horizontal checkboxes
                 ['gap'] = {the x distance between each button, the z difference between each button},
                 ['mod'] = { x position of the center of the button relative to the Text Tool, z position of the center of the button relative to the Text Tool }
                 ['listVariables'] = { 'the names of each item the checkbox will represent','separated by commas','do not use numbers' },
                 (optional)['modSize'] = size of the button -defaults to 200-, (optional)['color'] = color of the Text Tool -defaults to 'Grey'-,
                 (optional)['alwaysVisible'] = 0 to only show buttons when in "Edit Mode" or 1 to always display buttons -defaults to 0-,
                 (optional)['triggerUpdate'] = false to prevent the button(s) from calling calculateCharacterSheetValues() when modified or true to make the button(s) call the function when modified -defaults to false-
                 (optional)['tab'] = 'the tab table in the tabOffsetList you want this item to belong to -defaults to nil-'
             }
    --]]

    ['Success_Save']                = { 7.94,-5.1,  ['rotation'] = {0,270,0}, ['size'] = 40, ['gap'] = {0,0.59}, ['mod'] = {-0.3,-0.3}, ['listVariables'] = {'First','Second','Third'},  ['color'] = 'Black', ['modSize'] = 100},
    ['Fail_Save']                   = { 7.94,-4.65, ['rotation'] = {0,270,0}, ['size'] = 40, ['gap'] = {0,0.59}, ['mod'] = {0.3,-0.3}, ['listVariables'] = {'First','Second','Third'},  ['color'] = 'Black', ['modSize'] = 100},
    ['Skill_Proficiencies']         = { 12.89858,-0.68993, ['size'] = 26, ['gap'] = {0,0.39}, ['mod'] = {0.3,-0.24}, ['listVariables'] = {'Acrobatics','Animal Handling','Arcana','Athletics','Deception','History','Insight','Intimidation','Investigation',
                                                                                                                'Medicine','Nature','Perception','Performance','Persuasion','Religion','Sleight Of Hand','Stealth','Survival'},  ['color'] = 'Black', ['triggerUpdate'] = true, ['modSize'] = 100},
    ['Saving_Throws_Proficiencies'] = { 12.89858,-3.94673, ['size'] = 26, ['gap'] = {0,0.39}, ['mod'] = {0.3,-0.24}, ['listVariables'] = {'STR','DEX','CON','INT','WIS','CHA'}, ['color'] = 'Black', ['triggerUpdate'] = true, ['modSize'] = 100}
}

textOffsetList = { -- Text Tools that will be unlocked - for words

    --[[
    Format for each line:
    [Name] = {
                 x position of Text Tool, z position of Text Tool, ['size'] = font size,
                 (optional)['color'] = color of the Text Tool or true to be the player's color -defaults to 'Grey'-,
             }
    --]]

    ['Path']            = { 7.767517,-6.87593, ['size'] = 24},
    ['Background']      = { 4.656049,-7.57593, ['size'] = 24},
    ['Alignment']       = { 4.632616,-6.87593, ['size'] = 24},
    ['Party']           = { 1.564409,-6.87593, ['size'] = 24},
    ['Race_Class']      = { 7.707871,-7.57593, ['size'] = 24},
    ['Character_Level'] = { 10.19124,-7.30251, ['size'] = 32, ['color'] = 'Black'},
    ['Character_Name']  = { 13.26529,-7.56156, ['size'] = 36, ['color'] = true}
}

inertOffsetList = { -- Text Tools that are only interacted upon by other changing other Text Tools or conditions.

    --[[
    Format for each line:
    [Name] = {
                 x position of Text Tool, z position of Text Tool, ['size'] = font size,
                 (optional)['color'] = color of the Text Tool or true to be the player's color -defaults to 'Grey'-,
             }
    --]]

    ['Player']                = { 1.564409,-7.57593, ['size'] = 24},
    ['STRMod']                = { 13.78865,-5.7159,  ['size'] = 40, ['color'] = 'Red'},
    ['DEXMod']                = { 13.78865,-3.25593, ['size'] = 40, ['color'] = 'Green'},
    ['CONMod']                = { 13.78865,-0.76592, ['size'] = 40, ['color'] = 'Black'},
    ['INTMod']                = { 13.78865,1.72407,  ['size'] = 40, ['color'] = 'Blue'},
    ['WISMod']                = { 13.78865,4.254094, ['size'] = 40, ['color'] = 'Pink'},
    ['CHAMod']                = { 13.78865,6.74407,  ['size'] = 40, ['color'] = 'Yellow'},
    ['Passive_Perception']    = { 12.71865,7.22407,  ['size'] = 40},
    ['Skill_Numbers']         = { 12.49865,-0.69991, ['size'] = 26},
    ['Saving_Throws_Numbers'] = { 12.48865,-3.94673, ['size'] = 26}
}

tabsOffsetList = { -- Buttons that change what text tools and objects are on the sheet

    --[[
    Format for each line:
    [Name] = {
                 x position of Text Tool, z position of Text Tool, ['size'] = font size,
                 ['text'] = 'the button label'
                 ['set'] = {the different toggle displays},
                 ['mod'] = { x position of the center of the button relative to the Text Tool, z position of the center of the button relative to the Text Tool }
                 (optional)['modSize'] = size of the button -defaults to 200-, (optional)['color'] = color of the Text Tool -defaults to 'Grey'-,
                 (optional)['alwaysVisible'] = 0 to only show buttons when in "Edit Mode" or 1 to always display buttons -defaults to 0-,
                 (optional)['triggerUpdate'] = false to prevent the button(s) from calling calculateCharacterSheetValues() when modified or true to make the button(s) call the function when modified -defaults to false-
             }
    --]]

    ['Tab_1'] = { -1.5,-7.1, ['text'] = 'Combat',    ['size'] = 30, ['mod'] = {0,0.18},  ['modSize'] = 450, ['color']='Platinum', ['alwaysVisible'] = true},
    ['Tab_2'] = { -4,-7.1,   ['text'] = 'Spellbook', ['size'] = 30, ['mod'] = {0,0.18},  ['modSize'] = 450, ['color']='Platinum', ['alwaysVisible'] = true},
    ['Tab_3'] = { -6,-7.1,   ['text'] = 'Bio',       ['size'] = 30, ['mod'] = {0,0.18},  ['modSize'] = 450, ['color']='Platinum', ['alwaysVisible'] = true},
    ['Tab_4'] = { -8,-7.1,   ['text'] = '[Notes]',   ['size'] = 30, ['mod'] = {0,0.18},  ['modSize'] = 450, ['color']='Copper',   ['alwaysVisible'] = true}
}

zoneColor = {
    ['4201a1'] = 'Red',
    ['4201a2'] = 'Orange',
    ['4201a3'] = 'Yellow',
    ['4201a4'] = 'Green',
    ['4201a5'] = 'Blue',
    ['4201a9'] = 'Purple'
}

sheetPos = {
    ['Red'] = {-26.5910873,1.07,-40.87593},
    ['Orange'] = {19.4391747,1.07,-40.87593},
    ['Yellow'] = {58.7964745,1.07,-18.4719715},
    ['Green'] = {58.7964745,1.07,18.4564972},
    ['Blue'] = {19.4391747,1.07,40.87593},
    ['Purple'] = {-26.2886486,1.07,40.87593}
}

sheetRot = {
    ['Red'] = {0,180,0},
    ['Orange'] = {0,180,0},
    ['Yellow'] = {0,90,0},
    ['Green'] = {0,90,0},
    ['Blue'] = {0,0,0},
    ['Purple'] = {0,0,0}
}

playerInformation = {
    ['Red'] = {},
    ['Orange'] = {},
    ['Yellow'] = {},
    ['Green'] = {},
    ['Blue'] = {},
    ['Purple'] = {}
}

diffuseURL = {
    ['Red'] = 'http://i.imgur.com/Cjxl27X.png',
    ['Orange'] = 'http://i.imgur.com/BgykAHw.png',
    ['Yellow'] = 'http://i.imgur.com/PyOqEio.png',
    ['Green'] = 'http://i.imgur.com/apMwPRx.png',
    ['Blue'] = 'http://i.imgur.com/cDR9t6o.png',
    ['Purple'] = 'http://i.imgur.com/TKJSAjY.png'
}

function onload(save_state)
    lookupButtonData = {}
    keyLookup = {}
    customSheet = false
    circle = Global.getVar('unicodeCircle')

    config = Global.getVar('config')
    tool = Global.getVar('tool')
    roll = Global.getVar('roll')

    currentPlayers = getSeatedPlayersExcept({'White'})
    --createCache()
    -- Calculate Lookup
    local offsetListArray = {incrementalOffsetList,toggleOffsetList,checkboxOffsetList,tabsOffsetList}
    for index,offsetList in pairs(offsetListArray) do
        for key,value in pairs(offsetList) do
            local switch = {
                [1] = function() -- incrementalOffsetList
                    lookupButtonData[key]['1stPos'] = {value['mod'][1] + value['gap'][1],0,value['mod'][2] + value['gap'][2]}
                    lookupButtonData[key]['2ndPos'] = {value['mod'][1] - value['gap'][1],0,value['mod'][2] - value['gap'][2]}
                end,
                [2] = function() -- toggleOffsetList
                    lookupButtonData[key]['set'] = value['set']
                    lookupButtonData[key]['pos'] = {value['mod'][1],0,value['mod'][2]}
                end,
                [3] = function() -- checkboxOffsetList
                    lookupButtonData[key]['gap'] = value['gap']
                    lookupButtonData[key]['pos'] = {value['mod'][1],0,value['mod'][2]}
                    local iterator = 0
                    for i,v in pairs(value['listVariables']) do
                        self.setVar('lookupButtonData'..key..i,function(obj,color) modifierCheckbox(obj,color,v) end)
                        iterator = iterator + 1
                    end
                    lookupButtonData[key]['listSize'] = iterator
                end,
                [4] = function() -- tabsOffsetList
                    lookupButtonData[key]['pos'] = {value['mod'][1],0,value['mod'][2]}
                end
            }
            lookupButtonData[key] = {}
            lookupButtonData[key]['modSize'] = value['modSize'] or 200
            lookupButtonData[key]['triggerUpdate'] = value['triggerUpdate'] or false
            switch[index]()
        end
    end

    if save_state == "[]" or save_state == "" then
        CharacterSheets = {}
        CharacterJournals = {}
        keyLookupGUID = {}
    else
        --print(save_state)
        local function getObjectFromGUIDTable(e)
            local result = {}
            for key,guid in pairs(e) do
                if type(guid) == "table" then
                    result[key] = getObjectFromGUIDTable(guid)
                elseif type(guid) == "string" and getObjectFromGUID(guid) == nil then -- For scrollbar above&below information
                    result[key] = guid
                else
                    result[key] = getObjectFromGUID(guid)
                end
            end
            return result
        end
        local savedVars = JSON.decode(save_state)
        CharacterSheets   = getObjectFromGUIDTable(savedVars['CharacterSheets'])
        playerInformation = getObjectFromGUIDTable(savedVars['playerInformation'])
        CharacterJournals = getObjectFromGUIDTable(savedVars['CharacterJournals'])
        keyLookupGUID = savedVars['keyLookupGUID']
        -- Saving Safe
        for key,color in pairs(Global.getTable('colorTable')) do
            if next(playerInformation[color]) ~= nil then
                if not Player[color].seated then -- if theres info and is not seated, delete
                    if CharacterJournals[color] ~= nil then closeBook(color) end
                    destroyCharacterSheet(color)
                else -- there's info and someones seated - reassociate
                    tool.call('loadPlayer',{color})
                    local function deepInteractable(e)
                        for key,object in pairs(e) do
                            if type(object) == "table" then
                                deepInteractable(object)
                            elseif string.sub(tostring(object),1,-30) ~= "Notecard" then
                                object.interactable = false
                            end
                        end
                    end
                    --deepInteractable(playerInformation[color])
                    CharacterSheets[color]['interactable'] = false
                    Global.call('setZone',{color,1})
                end
                if CharacterJournals[color] ~= nil then
                    enableManager(color)
                    Global.call('setZone',{color,2})
                end
            else
                if Player[color].seated then -- if theres no info but someone is seated, spawn
                    initSheet(color)
                end
            end
        end -- for
    end

--[[
    -- This spawns new sheets for all players
    currentPlayers = getSeatedPlayersExcept({'White'})
    for i=1,#currentPlayers do
        if currentPlayers[i] ~= 'Grey' and currentPlayers[i] ~= 'Black' and currentPlayers[i] ~= 'White' then
            initSheet(currentPlayers[i])
        end
    end
]]
end

x = 0
function onSave()
    local savedVars = {}
    local function getGUIDFromObjectTable(e)
        local result = {}
        for key,object in pairs(e) do
            if type(object) == "table" then
                result[key] = getGUIDFromObjectTable(object)
            elseif type(object) == "string" and object.tag == nil then -- For scrollbar above&below information
                result[key] = object
            else
                result[key] = object.getGUID()
            end
        end
        return result
    end

    savedVars['CharacterSheets'] = getGUIDFromObjectTable(CharacterSheets)
    savedVars['CharacterJournals'] = getGUIDFromObjectTable(CharacterJournals)
    savedVars['playerInformation'] = getGUIDFromObjectTable(playerInformation)
    savedVars['keyLookupGUID'] = keyLookupGUID


    --if x==0 then print_r(savedVars) x=1 end
    return JSON.encode_pretty(savedVars)
end

function initSheet(color)
    keyLookup[color] = {}
    playerInformation[color]['edit'] = {}
    playerInformation[color]['edit']['incremental'] = {}
    playerInformation[color]['edit']['incremental']['alwaysVisible'] = {}
    playerInformation[color]['edit']['toggle'] = {}
    playerInformation[color]['edit']['toggle']['alwaysVisible'] = {}
    playerInformation[color]['edit']['checkbox'] = {}
    playerInformation[color]['edit']['checkbox']['alwaysVisible'] = {}
    playerInformation[color]['edit']['tabs'] = {}
    playerInformation[color]['edit']['tabs']['alwaysVisible'] = {}
    playerInformation[color]['scrollbars'] = {}
    playerInformation[color]['tabs'] = {}
    playerInformation[color]['tabModifiers'] = {}
    for tabName,value in pairs(tabsOffsetList) do -- Initialize tables for tabs and tab modifiers
        playerInformation[color]['tabModifiers'][tabName] = {}
        playerInformation[color]['tabModifiers'][tabName]['alwaysVisible'] = {}
        playerInformation[color]['tabs'][tabName] = {}
    end

    local sheet = spawnObject({
        ['type'] = 'Custom_Model',
        ['position'] = sheetPos[color],
        ['rotation'] = sheetRot[color]
    })

    sheet.setCustomObject({
        ['mesh'] = 'http://pastebin.com/raw/WM95FWL5',
        ['diffuse'] = diffuseURL[color],
        ['type'] = 4, -- Board
        ['material'] = 3, -- Cardboard
        ['specular_intensity'] = 0.1,
        ['specular_sharpness'] = 7.25,
        ['fresnel_strength'] = 0.60,
        ['cast_shadows'] = false
    })
    sheet['interactable'] = false
    sheet.setName(color.."CS")
    sheet.lock()
    CharacterSheets[color] = sheet

    local offsetArray = {objectOffsetList,textOffsetList,inertOffsetList,incrementalOffsetList,toggleOffsetList,checkboxOffsetList,tabsOffsetList}
    for index,offsetList in ipairs(offsetArray) do
        local position = {}
        local rotation = {}
        local obj
        for key,value in pairs(offsetList) do
            rotation = value['rotation'] or {0,0,0}
            if color == 'Purple' or color == 'Blue' then
                position = {sheetPos[color][1] + value[1],1.08,sheetPos[color][3] + value[2]}
                rotation = {(90 + rotation[1])%360,(180 + rotation[2])%360,(0 + rotation[3])%360}
            elseif color == 'Red' or color == 'Orange' then
                position = {sheetPos[color][1] - value[1],1.08,sheetPos[color][3] - value[2]}
                rotation = {(90 + rotation[1])%360,(0 + rotation[2])%360,(0 + rotation[3])%360}
            elseif color == 'Yellow' or color == 'Green' then
                position = {sheetPos[color][1] + value[2],1.08,sheetPos[color][3] - value[1]}
                rotation = {(90 + rotation[1])%360,(270 + rotation[2])%360,(0 + rotation[3])%360}
            end

            if index > 1 then -- Avoid spawning objects as textools
                local tabPosition = position
                if value['tab'] ~= nil then -- preparing to hide the object if it's supposed to part of a 'tab'
                    tabPosition = {position[1],position[2]-5,position[3]}
                end
                obj = spawnObject({
                    ['type'] = '3DText',
                    ['position'] = tabPosition
                })
                obj.setRotationSmooth(rotation)
                obj.TextTool.setFontSize(value['size'] or 64)
                obj.TextTool.setFontColor(returnColorTable(value['color'] or 'Grey'))
                obj.TextTool.setValue(value['text'] or ' ')
                obj['interactable'] = false
            end
            local switch = {
                [1] = function () -- objects
                    if value['tab'] ~= nil then
                        position[2] = position[2] - 6.08 + value['height'] -- adjusting user set height against base text tool height
                    else
                        position[2] = value['height']
                    end
                    obj = spawnObject({
                        ['type'] = value['type'],
                        ['position'] = position,
                        ['rotation'] = rotation
                    })
                    obj.setName(value['name'] or '')
                    obj.setScale({value['scale'],value['scale'],value['scale']})
                    obj.lock()
                    if value['tab'] ~= nil then
                        obj['interactable'] = false
                    end
                end,
                [2] = function() -- text, inert
                    if value['color'] == true then obj.TextTool.setFontColor(returnColorTable(color)) end
                end,
                [3] = function() -- incremental, toggle, checkbox, tabs
                    local modifier = spawnObject({
                        ['type'] = 'Custom_Model',
                        ['position'] = position,
                        ['rotation'] = {rotation[1]-270,rotation[2],0}
                    })
                    modifier.setColorTint({0,0,0})
                    modifier.setCustomObject({['mesh'] = 'http://pastebin.com/raw/yteXiDWq'})
                    modifier.lock()
                    local offsetNames = {'incremental','toggle','checkbox','tabs'}
                    if value['alwaysVisible'] == true then
                        playerInformation[color]['edit'][offsetNames[index-3]]['alwaysVisible'][key] = modifier
                        if value['tab'] ~= nil then
                            playerInformation[color]['tabModifiers'][value['tab']]['alwaysVisible'][key] = modifier
                            modifier.setScale({0,0,0}) -- Always visible tab buttons are activated with the tab's button
                        end
                    else
                        playerInformation[color]['edit'][offsetNames[index-3]][key] = modifier
                        modifier.setScale({0,0,0})
                        if value['tab'] ~= nil then
                            playerInformation[color]['tabModifiers'][value['tab']][key] = modifier
                        end
                    end
                    keyLookup[color][obj] = modifier
                end
            }
            if index == 1 then -- Validate Execution
                switch[1]()
            elseif index == 2 or index == 3 then
                switch[2]()
            elseif index >= 4 and index <= 7 then
                switch[3]()
            else
                print('Failure to load all offset tables. Please revise your custom character sheet code.')
            end
            if value['tab'] ~= nil then
                playerInformation[color]['tabs'][value['tab']][key] = obj -- With this, items belonging to tabs are saved in both the main item directory, meaning playerInformation[color][key], as well as this new one. Functional, but inefficient.
            end
            playerInformation[color][key] = obj
        end
    end
    Timer.create({
        ['identifier'] = 'initPlayer'..color,
        ['function_name'] = 'initPlayer',
        ['function_owner'] = self,
        ['parameters'] = {color},
        ['delay'] = 0.2
    })
end

function initPlayer(color) -- Receives Table
    color = color[1]
    -- Executes 1 second after everything in a char sheet is spawned
    keyLookupGUID[color] = {}
    for key,value in pairs(keyLookup[color]) do
        keyLookupGUID[color][key.getGUID()] = value.getGUID()
    end
    tool.call('loadPlayer',{color})
    Global.call('setZone',{color,1})
end

-- Triggered when valid book enters available zone - called from onObjectEnterScriptingZone
function loadCharacter(arg)
    local enter_object = arg[1]
    local zone = arg[2]
    local color = arg[3]
    openBook(enter_object,zone)
    enableManager(color)
end


function openBook(book,zone)
    local param = book.getCustomObject()
    param['mesh'] = 'http://pastebin.com/raw/YTsHZRfG'
    param['diffuse'] = 'http://i.imgur.com/XgSo3GV.png'
    local obj = spawnObject({
        type = 'Custom_Model',
        position = zone.getPosition(),
        rotation = zone.getRotation()
    })
    obj.setCustomObject(param)

    local code = book.getLuaScript()
    obj.setLuaScript(code)
    obj.setVar('open', 1)
    obj['interactable'] = false
    CharacterJournals[keyFromValue(Global.getTable('zoneFromColor'),zone.guid)] = obj
    readFromBook(keyFromValue(Global.getTable('zoneFromColor'),zone.guid),book)
    book.destruct()
end

function enableManager(color)
    -- This funciton enables buttons

    -- Called when:
    -- 1) A character has finished loading, after open Book.
    -- 2) A rewind/reload was made and sheet needs buttons.

    local function createScrollbarButtonsFromTable(table)
        for key,object in pairs(table) do
            if object['type'] == 'Notecard' and object['scrollbar'] == true then
                Global.call('addButton',{playerInformation[color][key].getGUID(), 1,1,1,'','scrollUp',self,{-0.38,0,0.35},{0,-90,0}})
                Global.call('addButton',{playerInformation[color][key].getGUID(), 0,0,70,'<','placeHolder',self,{-0.46,5,0.45},{0,-90,0}})
                Global.call('addButton',{playerInformation[color][key].getGUID(), 1,1,1,'','scrollDown',self,{-0.38,0,-0.35},{0,90,0}})
                Global.call('addButton',{playerInformation[color][key].getGUID(), 0,0,70,'<','placeHolder',self,{-0.46,5,-0.45},{0,90,0}})
            end
        end
    end

    local function createIncrementButtonsFromTable(table)
        for key,object in pairs(table) do
            if type(object) == 'table' then
                createIncrementButtonsFromTable(object)
            else
                local modSize = lookupButtonData[key]['modSize']
                Global.call('addButton',{object.getGUID(),modSize,modSize,modSize,'-','modifierSub',self,lookupButtonData[key]['1stPos']})
                Global.call('addButton',{object.getGUID(),modSize,modSize,modSize,'+','modifierAdd',self,lookupButtonData[key]['2ndPos']})
            end
        end
    end

    local function createToggleButtonsFromTable(table)
        for key,object in pairs(table) do
            if type(object) == 'table' then
                createToggleButtonsFromTable(object)
            else
                local modSize = lookupButtonData[key]['modSize']
                Global.call('addButton',{object.getGUID(),modSize,modSize,modSize,' ','modifierToggle',self,lookupButtonData[key]['pos']})
            end
        end
    end

    local function createCheckboxButtonsFromTable(table)
        for key,object in pairs(table) do
            if type(object) == 'table' then
                createCheckboxButtonsFromTable(object)
            else
                local modSize = lookupButtonData[key]['modSize']
                local pos = lookupButtonData[key]['pos']
                for i=1,lookupButtonData[key]['listSize'] do
                    pos = {pos[1] + lookupButtonData[key]['gap'][1],0,pos[3] + lookupButtonData[key]['gap'][2]}
                    Global.call('addButton',{object.getGUID(),modSize,modSize,modSize,'x','lookupButtonData'..key..i,self,pos})
                end
            end
        end
    end

    local function createTabsButtonsFromTable(table)
        for key,object in pairs(table) do
            if type(object) == 'table' then
                createTabsButtonsFromTable(object)
            else
                local modSize = lookupButtonData[key]['modSize']
                Global.call('addButton',{object.getGUID(),modSize,modSize,modSize,' ','modifierTabs',self,lookupButtonData[key]['pos']})
            end
        end
    end

    --CharacterSheets[color].setVar('color',color)

    -- TODO: Decide where and how edit mode is reset
    --CharacterSheets[color].setVar('edit',1)
    --shrinkEditModeButtons(color)
    Global.call('addButton', {CharacterSheets[color].getGUID(),3000,500,350,'Spawn Figurine','nil',self,{13.2,0.01,-2.3}})
    Global.call('addButton', {CharacterSheets[color].getGUID(),3000,500,350,'Add XP/Level Up','nil',self,{13.2,0.01,-1.0}})
    Global.call('addButton', {CharacterSheets[color].getGUID(),3000,500,350,'Something','nil',self,{13.2,0.01,0.3}})
    Global.call('addButton', {CharacterSheets[color].getGUID(),3000,500,350,'DEBUG: NOTECARDS','DEBUGPrintNotecardPos',self,{13.2,0.01,1.6}})
    Global.call('addButton', {CharacterSheets[color].getGUID(),3000,500,350,'DEBUG: JOURNAL','DEBUGprintJournal',self,{13.2,0.01,2.9}})
    Global.call('addButton', {CharacterSheets[color].getGUID(),3000,500,350,'DEBUG: INFO','DEBUGprintPlayerInfo',self,{13.2,0.01,4.2}})
    Global.call('addButton', {CharacterSheets[color].getGUID(),3000,500,350,'Edit Sheet','toggleEdit',self,{13.2,0.01,5.5}})
    Global.call('addButton', {CharacterSheets[color].getGUID(),3000,600,350,'Save & Close','saveCharacter',self,{13.2,0.01,7.2}})
    createIncrementButtonsFromTable(playerInformation[color]['edit']['incremental'])
    createToggleButtonsFromTable(playerInformation[color]['edit']['toggle'])
    createCheckboxButtonsFromTable(playerInformation[color]['edit']['checkbox'])
    createTabsButtonsFromTable(playerInformation[color]['edit']['tabs'])
    createScrollbarButtonsFromTable(objectOffsetList)
end

function toggleEdit(obj,color)
    -- TODO: Validate that player clicking is the owner of the sheet

    local labels = {'Edit Sheet','Exit Edit Mode'}
    --local msg = {DA.."Edit Mode is now off.",DA.."You are now editing your sheet. To Finish editing, Press \"Exit Edit Mode\""}
    local x = 1 - (obj.getVar('editMode') or 0)
    obj.setVar('editMode', x)
    params = obj.getButtons()
    params[7]['label'] = labels[x+1]
    --printToColor(msg[x+1],player,{0.2,0.8,0.8})
    obj.editButton(params[7])
    local offsetNames = {'incremental','toggle','checkbox','tabs'}

    local action = {
        [0] = function() -- Edit mode OFF
            for i=1,4 do
                for index,modifier in pairs(playerInformation[color]['edit'][offsetNames[i]]) do
                    if type(modifier) ~= 'table' then
                        modifier.setScale({0,0,0})
                    end
                end
            end
            for key,_ in pairs(textOffsetList) do
                playerInformation[color][key]['interactable'] = false
            end
        end,
        [1] = function() -- Edit mode ON
            for i=1,4 do
                for _,object in pairs(playerInformation[color]['edit'][offsetNames[i]]) do
                    if type(object) ~= 'table' then
                        object.setScale({1,1,1})
                    end
                end
            end
            for tab,_ in pairs(tabsOffsetList) do -- disable non-currentTab tab items.
                if obj.getVar('currentTab') ~= tab then
                    for index,modifier in pairs(playerInformation[color]['tabModifiers'][tab]) do
                        if type(modifier) ~= 'table' then
                            modifier.setScale({0,0,0})
                        end
                    end
                end
            end
            for key,_ in pairs(textOffsetList) do
                playerInformation[color][key]['interactable'] = true
            end
        end
    }
    action[x]()
end

function modifierAdd(obj,color) -- Called from a + incremental button
    local counter = getObjectFromGUID(keyFromValue(keyLookupGUID[color],obj.guid))
    local key = keyFromValue(playerInformation[color],counter)
    local newValue
    if contains(Base_Stats,key) then
        local BSTable = CharacterJournals[color].getTable('Base_Stats')
        newValue = BSTable[key] + 1
        BSTable[key] = newValue
        CharacterJournals[color].setTable('Base_Stats',BSTable)
    else
        newValue = CharacterJournals[color].getVar(key) or 0
        newValue = newValue + 1
        CharacterJournals[color].setVar(key,newValue)
    end
    counter.TextTool.setValue(tostring(newValue))
    if lookupButtonData[key]['triggerUpdate'] == true then calculateCharacterSheetValues(color) end
end

function modifierSub(obj,color) -- Called from a - incremental button
    local counter = getObjectFromGUID(keyFromValue(keyLookupGUID[color],obj.guid))
    local key = keyFromValue(playerInformation[color],counter)
    local newValue
    if contains(Base_Stats,key) then
        local BSTable = CharacterJournals[color].getTable('Base_Stats')
        newValue = BSTable[key] - 1
        BSTable[key] = newValue
        CharacterJournals[color].setTable('Base_Stats',BSTable)
    else
        newValue = CharacterJournals[color].getVar(key) or 0
        newValue = newValue - 1
        CharacterJournals[color].setVar(key,newValue)
    end
    counter.TextTool.setValue(tostring(newValue))
    if lookupButtonData[key]['triggerUpdate'] == true then calculateCharacterSheetValues(color) end
end

function modifierToggle(obj,color) -- Called from a toggle button
    local toggle = getObjectFromGUID(keyFromValue(keyLookupGUID[color],obj.guid))
    local key = keyFromValue(playerInformation[color],toggle)
    local index = keyFromValue(lookupButtonData[key]['set'],CharacterJournals[color].getVar(key))
    local newValue = lookupButtonData[key]['set'][next(lookupButtonData[key]['set'],index)] or lookupButtonData[key]['set'][1]
    CharacterJournals[color].setVar(key,newValue)
    toggle.TextTool.setValue(newValue)
    if lookupButtonData[key]['triggerUpdate'] == true then calculateCharacterSheetValues(color) end
end

function modifierCheckbox(obj,color,element) -- Called from a checkbox button
    if tonumber(element) then print('Invalid checkbox element, do not use numbers as strings in the set. Edit your custom sheet.')
    else
        local checkbox = getObjectFromGUID(keyFromValue(keyLookupGUID[color],obj.guid))
        local key = keyFromValue(playerInformation[color],checkbox)
        local workTable = CharacterJournals[color].getTable(key)
        workTable[element] = not workTable[element]
        CharacterJournals[color].setTable(key,workTable)
        checkbox.TextTool.setValue(getProficienciesString(color,key))
        if lookupButtonData[key]['triggerUpdate'] == true then calculateCharacterSheetValues(color) end
    end
end

function modifierTabs(obj,color) -- Called from a tab button
    local tab = getObjectFromGUID(keyFromValue(keyLookupGUID[color],obj.guid))
    local key = keyFromValue(playerInformation[color],tab)
    local currentTab = CharacterSheets[color].getVar('currentTab') or 'none'
    if currentTab ~= key then -- reset to default position where no tab is active
        resetTab(color)
        for index,obj in pairs(playerInformation[color]['tabs'][key]) do
            local pos = obj.getPosition()
            obj.setPosition({pos[1],pos[2]+5,pos[3]}) -- it might be better to use the original positioning information for this.
            obj['interactable'] = true
        end
        CharacterSheets[color].setVar('currentTab',key)
        for index,modifier in pairs(playerInformation[color]['tabModifiers'][key]['alwaysVisible']) do
            modifier.setScale({1,1,1}) -- Activate always visible buttons related ot the current tab
        end
        toggleEdit(CharacterSheets[color],color) -- Reset the state of edit mode to prevent lingering buttons
        toggleEdit(CharacterSheets[color],color)
    end
    if lookupButtonData[key]['triggerUpdate'] == true then calculateCharacterSheetValues(color) end
end

function resetTab(color)
    local currentTab = CharacterSheets[color].getVar('currentTab') or 'none'
    if currentTab ~= 'none' then
        for i,obj in pairs(playerInformation[color]['tabs'][currentTab]) do
            local pos = obj.getPosition()
            obj.setPosition({pos[1],pos[2]-5,pos[3]}) -- it might be better to use the original positioning information for this.
            obj['interactable'] = false
        end
        for index,modifier in pairs(playerInformation[color]['tabModifiers'][currentTab]['alwaysVisible']) do
            modifier.setScale({0,0,0}) -- Activate always visible buttons related ot the current tab
        end
        CharacterSheets[color].setVar('currentTab','none')
    end
end

function readFromBook(color,journal)
    local offsetArray = {toggleOffsetList, textOffsetList, inertOffsetList}
    for index,offset in pairs(offsetArray) do
        for key,value in pairs(offset) do
            CharacterJournals[color].setVar(key,journal.getVar(key))
            playerInformation[color][key].TextTool.setValue(tostring(journal.getVar(key)))
        end
    end

    for key,value in pairs(incrementalOffsetList) do
        if not contains(Base_Stats,key) then
            CharacterJournals[color].setVar(key,journal.getVar(key))
            playerInformation[color][key].TextTool.setValue(tostring(journal.getVar(key)))
        end
    end

    CharacterJournals[color].setTable('Base_Stats', journal.getTable('Base_Stats'))
    for key,value in pairs(CharacterJournals[color].getTable('Base_Stats')) do
        playerInformation[color][key].TextTool.setValue(tostring(value))
    end

    for key,value in pairs(checkboxOffsetList) do
        CharacterJournals[color].setTable(key, journal.getTable(key))
        playerInformation[color][key].TextTool.setValue(getProficienciesString(color,key))
    end

    for key,value in pairs(objectOffsetList) do
        if value['type'] ~= 'Notecard' then
            CharacterJournals[color].setVar(key,journal.getVar(key))
            playerInformation[color][key].setValue(journal.getVar(key))
            playerInformation[color][key].setName(value['name'])
        elseif value['name'] ~= 'Inventory' then
            CharacterJournals[color].setVar(key,journal.getVar(key))
            playerInformation[color][key].setName(value['name'])
            if value['scrollbar'] == true then -- setup the above and below variables
                local text = journal.getVar(key) or ''
                local newPage = tool.call('getPageAccessor',{text})
                playerInformation[color][key].setDescription(newPage)
                playerInformation[color]['scrollbars'][key] = {}
                playerInformation[color]['scrollbars'][key]['above'] = ''
                playerInformation[color]['scrollbars'][key]['below'] = tool.call('removeNewlineAccessor',{tool.call('removeNewlineAccessor',{tool.call('plainReplaceAccessor',{text,newPage,''}),'Beginning'}),'Ending'})
                playerInformation[color]['scrollbars'][key]['starting'] = playerInformation[color][key].getDescription()
            else
                playerInformation[color][key].setDescription(journal.getVar(key))
            end
        end
    end

    tool.call('setupNewInventory',{color,journal.getVar('Inventory')})

    getObjectFromGUID(color.."NameDisplay").TextTool.setValue(journal.getVar('Character_Name')) -- Will this work in custom?

    local DMCounter = getObjectFromGUID(tool.getTable('DMHealthCounterGUIDs')[keyFromValue(Global.getVar('colorTable'),color)])
    DMCounter.setName(journal.getVar('Character_Name').."'s Health")
    DMCounter.Counter.setValue(journal.getVar('HP'))
    playerInformation[color]['HP'].Counter.setValue(journal.getVar('HP'))

    calculateCharacterSheetValues(color)
end

function saveCharacter(obj,color)
    -- delete buttons
    -- save variables
    -- close book
    -- destruct figurine
    -- on book exit - change zone to 1
    CharacterSheets[color].clearButtons()
    if obj.getVar('editMode') == 1 then -- Set edit buttons back to default.
        toggleEdit(obj,color)
    end
    resetTab(color)
    --destroyCharacterSheet(color)
    --initSheet(color)
    closeBook(color)
    cleanText(color)
    Global.call('setZone',{color,1})
end

function closeBook(color)
    local param = CharacterJournals[color].getCustomObject()
        local pos = CharacterJournals[color].getPosition()
        if color == 'Blue' or color == 'Purple' then
            pos = {pos[1],pos[2],pos[3]+7}
        elseif color == 'Green' or color == 'Yellow' then
            pos = {pos[1]+7,pos[2],pos[3]}
        elseif color == 'Red' or color == 'Orange' then
            pos = {pos[1],pos[2],pos[3]-7}
        end
        local obj_param = {
            ['type'] = 'Custom_Model',
            ['position'] = pos,
            ['rotation'] = CharacterJournals[color].getRotation(),
        }

        local obj = spawnObject(obj_param)
        param["mesh"] = "http://pastebin.com/raw/y4hs8Riy"
        param["diffuse"] = "http://i.imgur.com/eT6yiIu.png"
        obj.setCustomObject(param)

        obj.setLuaScript(encodeBook(color))
        destroyObject(CharacterJournals[color])
        CharacterJournals[color] = nil
        --obj['interactable'] = true
end

function destroyCharacterSheet(color)
    if Global.call('getZone',{color}) == 2 then
        closeBook(color)
    end
    cleanText(color)
    CharacterSheets[color].destruct() -- Sheet Itself
    CharacterSheets[color] = nil
    destroyObjects(playerInformation[color])
    for k in pairs(keyLookupGUID[color]) do keyLookupGUID[color][k] = nil end
    keyLookupGUID[color] = nil
    Global.call('setZone',{color,0})
    getObjectFromGUID("TOOLS").call('removePlayerButton',{color})
end

function destroyObjects(table)
    for key,value in pairs(table) do
        if type(value) == 'userdata' then
            value.destruct()
        --else destroyObjects(value)
        elseif type(value) == "table" then
            destroyObjects(value)
        end
        table[key] = nil
    end
end

function cleanText(color)
    local offsetArray = {incrementalOffsetList,toggleOffsetList,checkboxOffsetList,textOffsetList,inertOffsetList}
    for index,offset in pairs(offsetArray) do
        for key,value in pairs(offset) do
            playerInformation[color][key].TextTool.setValue(' ')
        end
    end

    for key,value in pairs(objectOffsetList) do
        if value['type'] ~= 'Notecard' then
            playerInformation[color][key].setValue(0)
            playerInformation[color][key].setName('')
        else
            playerInformation[color][key].setDescription('')
            playerInformation[color][key].setName('')
        end
    end

    local DMCounter = getObjectFromGUID(tool.getTable('DMHealthCounterGUIDs')[keyFromValue(Global.getVar('colorTable'),color)])
    DMCounter.setName(' ')
    DMCounter.Counter.setValue(0)
    playerInformation[color]['HP'].Counter.setValue(0)

    getObjectFromGUID(color.."NameDisplay").TextTool.setValue(' ')
end

function onPlayerChangedColor(color)
    local oldColor = {}
    local holdPlayers = getSeatedPlayersExcept({'White',color})
    oldColor = array_sub(holdPlayers,currentPlayers)
    if color == 'Grey' then
        if oldColor[1] != 'White' and oldColor[1] ~= nil then
            destroyCharacterSheet(oldColor[1])
        end
    else
        if color != 'Black' then
            if color != 'White'then
                initSheet(color)
            end
        else
            print("[0ff4f0]PLEASE USE WHITE AS COLOR TO DM")
        end
        if oldColor[1] != 'White' and oldColor[1] ~= nil then
            destroyCharacterSheet(oldColor[1])
        end
            --pActiveZoneArray[getZoneGUIDFromColor(color)] = 1
    end
    currentPlayers = getSeatedPlayersExcept({'White'})
end

function encodeBook(color)
    local script = [[-- Quality RPG CHARACTER SAVE
-- ]].. os.date("Saved %X UTC ~ %a %d, %B %Y")..'\nversion = '..Global.getVar('currentVersion')

script = script..'\n\n--------------------------- Character Information ---------------------------\n'

    local offsetArray = {toggleOffsetList, textOffsetList, inertOffsetList}
    for index,offset in pairs(offsetArray) do
        for key,value in pairs(offset) do
            if tonumber(CharacterJournals[color].getVar(key)) then
                script = script..'\n'..key..' = '..CharacterJournals[color].getVar(key)
            else
                script = script..'\n'..key..' = \[\['..tostring(CharacterJournals[color].getVar(key))..'\]\]'
            end
        end
    end

    for key,value in pairs(incrementalOffsetList) do
        if not contains(Base_Stats,key) then
            script = script..'\n'..key..' = '..CharacterJournals[color].getVar(key)
        end
    end

    script = script..'\nBase_Stats = {'
    for key,value in pairs(CharacterJournals[color].getTable('Base_Stats')) do
        if tonumber(key) then
            script = script..'\n\t['..key..'] = '..value..','
        else
            script = script..'\n\t[\"'..key..'\"] = '..value..','
        end
    end

    script = string.sub(script,1,-2)
    script = script..'\n}\n'

    for key,value in pairs(checkboxOffsetList) do
        script = script..'\n'..key..' = {'
        for i,v in pairs(CharacterJournals[color].getTable(key)) do
            if tonumber(i) then
                script = script..'\n\t['..i..'] = '..tostring(v)..','
            else
                script = script..'\n\t[\"'..i..'\"] = '..tostring(v)..','
            end
        end
        script = string.sub(script,1,-2)
        script = script..'\n}\n'
    end

    for key,value in pairs(objectOffsetList) do
        if value['type'] ~= 'Notecard' then
            script = script..'\n'..key..' = '..playerInformation[color][key].getValue()
        else
            if value['scrollbar'] == true then
                script = script..'\n'..key..' = \[\['..getFullText(color,key)..'\]\]'
            else
                script = script..'\n'..key..' = \[\['..playerInformation[color][key].getDescription()..'\]\]'
            end
        end
    end

    script = script..'\n\nfunction onLoad(save_state)\n\tself.setName(Character_Name)\n\tself.setDescription("QRPG Character Save")\nend'

    return script
end

function createCache()
    for _,v in pairs(diffuseURL) do
        local sheet = spawnObject({
            ['type'] = 'Custom_Model',
            ['position'] = {0,-25,0}
        })
        sheet.setCustomObject({
        ['mesh'] = 'http://pastebin.com/raw/WM95FWL5',
        ['diffuse'] = v,
        })
        --sheet.setScale{0.001,0.001,0.001}
        sheet.lock()
        --sheet['interactable'] = false
    end
    local openBook = spawnObject({
        ['type'] = 'Custom_Model',
        ['position'] = {0,-25,0}
    })
    openBook.setCustomObject({
        ['mesh'] = 'http://pastebin.com/raw/YTsHZRfG',
        ['diffuse'] = 'http://i.imgur.com/XgSo3GV.png',
    })
    --openBook.setScale{0,0,0}
    openBook.lock()
    --openBook['interactable'] = false
    local closedBook = spawnObject({
        ['type'] = 'Custom_Model',
        ['position'] = {0,-25,0}
    })
    closedBook.setCustomObject({
        ['mesh'] = 'http://pastebin.com/raw/y4hs8Riy',
        ['diffuse'] = 'http://i.imgur.com/eT6yiIu.png',
    })
    --closedBook.setScale{0,0,0}
    closedBook.lock()
    --closedBook['interactable'] = false
end

function parseSave(content)
    local result = content:gsub("\n","\\n")
    return result:gsub("%'", "\\'")
    --return result
end

function returnColorTable(color)
    if color == true then return {['r']=0,['g']=0,['b']=0} end
    local tint = {
        ['Red']         = {0.856,0.1,0.094},
        ['Orange']      = {0.956,0.392,0.113},
        ['Yellow']      = {0.905,0.898,0.172},
        ['Green']       = {0.192,0.701,0.168},
        ['Blue']        = {0.118,0.53,1.0},
        ['Purple']      = {0.627,0.125,0.941},
        ['Black']       = {0,0,0},
        ['Grey']        = {0.84,0.84,0.84},
        ['White']       = {1,1,1},
        ['Pink']        = {1.0,0.3222451,1.0},
        ['Copper']      = {0.71,0.39,0.15},
        ['Silver']      = {0.75,0.75,0.75},
        ['Electrum']    = {0.8,0.81,0.6},
        ['Gold']        = {1.0,0.84,0.0},
        ['Platinum']    = {0.75,0.79,0.85},
    }
    return {['r']=tint[color][1],['g']=tint[color][2],['b']=tint[color][3]}
end

function array_sub(t1, t2)
  local t = {}
  local result = t2
  for i = 1, #t1 do
    t[t1[i]] = true;
  end
  for i = #t2, 1, -1 do
    if t[t2[i]] then
      table.remove(result, i);
    end
  end
  return result
end

function keyFromValue( t, value )
  for k,v in pairs(t) do
    if v==value then return k end
    end
  return nil
end

function contains(table, element)
  for _, value in pairs(table) do
    if value == element then
      return true
    end
  end
  return false
end

function getProficienciesString(color, tableName) -- Reads vars from the journal and creates a string of unicode circles based on the result.
    local str = ''
    local itemTable = CharacterJournals[color].getTable(tableName)
    for i,v in pairs(itemTable) do
        if itemTable[i] == true then
            str = str..circle..'\n'
        else
            str = str..'\n'
        end
    end
    return str
end

function calculateCharacterSheetValues(color)
    local str = ''

    -- Calculate Ability Modifiers.
    local abilityMod = {}
    local statTable = CharacterJournals[color].getTable('Base_Stats')
    for key,value in pairs(statTable) do
        abilityMod[key] = math.floor((value-10)/2)
        if abilityMod[key] > 0 then
            playerInformation[color][key..'Mod'].setValue('+'..tostring(abilityMod[key]))
        else
            playerInformation[color][key..'Mod'].setValue(tostring(abilityMod[key]))
        end
    end

    -- Calculate Saving Throws.
    statTable = CharacterJournals[color].getTable('Saving_Throws_Proficiencies')
    for key,value in pairs(statTable) do
        if value == true then
            str = str..tostring(abilityMod[key] + CharacterJournals[color].getVar('Proficiency_Bonus'))..'\n'
        else
            str = str..tostring(abilityMod[key])..'\n'
        end
    end
    playerInformation[color]['Saving_Throws_Numbers'].TextTool.setValue(str)

    -- Calculate Skill Scores
    str = ''
    statTable = CharacterJournals[color].getTable('Skill_Proficiencies')
    abilityModUseOrder = {'DEX','WIS','INT','STR','CHA','INT','WIS','CHA','INT','WIS','INT','WIS','CHA','CHA','INT','DEX','DEX','WIS'} -- The order of the skills in terms of their parent ability.
    local i = 1
    for key,value in pairs(statTable) do
        if value == true then
            str = str..tostring(abilityMod[abilityModUseOrder[i]] + CharacterJournals[color].getVar('Proficiency_Bonus'))..'\n'
        else
            str = str..tostring(abilityMod[abilityModUseOrder[i]])..'\n'
        end
        i = i+1
    end
    playerInformation[color]['Skill_Numbers'].TextTool.setValue(str)

    -- Calculate Passive Perception
    playerInformation[color]['Passive_Perception'].TextTool.setValue(tostring(10+abilityMod['WIS']))
end

function scrollUp(obj,color)
    local key = keyFromValue(playerInformation[color],obj)
    if playerInformation[color]['scrollbars'][key]['above'] ~= '' then
        local newPage = string.reverse(tool.call('getPageAccessor',{string.reverse(playerInformation[color]['scrollbars'][key]['above'])}))
        if obj.getDescription() ~= '' then
            local i = string.len(newPage)
            local tempPage = tool.call('getPageAccessor',{tool.call('removeNewlineAccessor',{tool.call('removeNewlineAccessor',{newPage..'\n'..tool.call('preserveNewlineAccessor',{obj.getDescription()}),'Ending'}),'Beginning'})})
            local j = string.len(tempPage)
            if i < j then
                newPage = tempPage
                playerInformation[color]['scrollbars'][key]['above'] = tool.call('removeNewlineAccessor',{tool.call('removeNewlineAccessor',{tool.call('plainReplaceAccessor',{playerInformation[color]['scrollbars'][key]['above'],string.sub(newPage,1,i),''}),'Ending'}),'Beginning'})
                playerInformation[color]['scrollbars'][key]['below'] = tool.call('removeNewlineAccessor',{tool.call('removeNewlineAccessor',{tool.call('plainReplaceAccessor',{tool.call('preserveNewlineAccessor',{obj.getDescription()}),tool.call('removeNewlineAccessor',{string.sub(newPage,i+1,j),'Beginning'}),''})..'\n'..playerInformation[color]['scrollbars'][key]['below'],'Beginning'}),'Ending'})
            else
                playerInformation[color]['scrollbars'][key]['above'] = tool.call('removeNewlineAccessor',{tool.call('plainReplaceAccessor',{playerInformation[color]['scrollbars'][key]['above'],tool.call('removeNewlineAccessor',{tool.call('removeNewlineAccessor',{newPage,'Ending'}),'Beginning'}),''}),'Ending'})
                playerInformation[color]['scrollbars'][key]['below'] = tool.call('removeNewlineAccessor',{tool.call('removeNewlineAccessor',{tool.call('preserveNewlineAccessor',{obj.getDescription()})..'\n'..playerInformation[color]['scrollbars'][key]['below'],'Ending'}),'Beginning'})
            end
        else
            playerInformation[color]['scrollbars'][key]['above'] = tool.call('removeNewlineAccessor',{tool.call('plainReplaceAccessor',{playerInformation[color]['scrollbars'][key]['above'],tool.call('removeNewlineAccessor',{tool.call('removeNewlineAccessor',{newPage,'Ending'}),'Beginning'}),''}),'Ending'})
        end
        obj.setDescription(tool.call('removeNewlineAccessor',{tool.call('removeNewlineAccessor',{newPage,'Ending'}),'Beginning'}))
        playerInformation[color]['scrollbars'][key]['starting'] = obj.getDescription()
    end
end

function scrollDown(obj,color)
    local key = keyFromValue(playerInformation[color],obj)
    if obj.getDescription() ~= '' or playerInformation[color]['scrollbars'][key]['below'] ~= '' then
        local newPage = tool.call('getPageAccessor',{tool.call('preserveNewlineAccessor',{obj.getDescription()})})
        playerInformation[color]['scrollbars'][key]['above'] = tool.call('removeNewlineAccessor',{playerInformation[color]['scrollbars'][key]['above']..'\n'..newPage,'Beginning'})
        local tempPage = string.sub(tool.call('preserveNewlineAccessor',{obj.getDescription()}),string.len(newPage)+1,-1)
        if tempPage ~= '' then
            newPage = tool.call('getPageAccessor',{tool.call('removeNewlineAccessor',{tool.call('removeNewlineAccessor',{tempPage..'\n'..playerInformation[color]['scrollbars'][key]['below'],'Ending'}),'Beginning'})})
            if string.len(newPage) > string.len(tempPage) then
                tempPage = ''
            end
        else
            tempPage = ''
            newPage = tool.call('getPageAccessor',{tool.call('removeNewlineAccessor',{tool.call('removeNewlineAccessor',{playerInformation[color]['scrollbars'][key]['below'],'Ending'}),'Beginning'})})
        end
        local extraLength1 = tool.call('getLinesAccessor',{tool.call('preserveNewlineAccessor',{obj.getDescription()})})
        local tempStartingText = tool.call('getLinesAccessor',{playerInformation[color]['scrollbars'][key]['starting']})
        local extraLength2 = extraLength1['lineCount'] - tempStartingText['lineCount']
        local extraLength3 = tool.call('getLinesAccessor',{playerInformation[color]['scrollbars'][key]['below']})
        local extraLength4 = tempStartingText['lineCount'] - extraLength2
        local extraLength5 = extraLength3[extraLength4]
        obj.setDescription(tool.call('removeNewlineAccessor',{tool.call('removeNewlineAccessor',{newPage,'Beginning'}),'Ending'}))
        playerInformation[color]['scrollbars'][key]['starting'] = obj.getDescription()
        if extraLength2 > 0 and extraLength4 <= extraLength3['lineCount'] and extraLength4 > 0 and extraLength5 ~= nil then
            playerInformation[color]['scrollbars'][key]['below'] = tool.call('removeNewlineAccessor',{string.sub(tempPage..playerInformation[color]['scrollbars'][key]['below'],extraLength5+1),'Beginning'})
        else
            if string.len(obj.getDescription()) ~= string.len(playerInformation[color]['scrollbars'][key]['below']) then
                playerInformation[color]['scrollbars'][key]['below'] = tool.call('removeNewlineAccessor',{tool.call('removeNewlineAccessor',{string.sub(tempPage..playerInformation[color]['scrollbars'][key]['below'],string.len(obj.getDescription())+2),'Ending'}),'Beginning'})
            else
                playerInformation[color]['scrollbars'][key]['below'] = ''
            end
        end
    end
end

function getFullText(color,key) -- returns the complete string of data for a card.
    local fullText = playerInformation[color][key].getDescription()
    if playerInformation[color]['scrollbars'][key]['above'] ~= '' then
        fullText = playerInformation[color]['scrollbars'][key]['above']..'\n'..fullText
    end
    if playerInformation[color]['scrollbars'][key]['below'] ~= '' then
        fullText = fullText..'\n'..playerInformation[color]['scrollbars'][key]['below']
    end
    return fullText
end


function print_r ( t )
    local print_r_cache={}
    local function sub_print_r(t,indent)
        if (print_r_cache[tostring(t)]) then
            print(indent.."*"..tostring(t))
        else
            print_r_cache[tostring(t)]=true
            if (type(t)=="table") then
                for pos,val in pairs(t) do
                    if (type(val)=="table") then
                        print(indent.."['"..pos.."\'] => "..tostring(t).." {")
                        sub_print_r(val,indent..string.rep(" ",string.len(pos)+8))
                        print(indent..string.rep(" ",string.len(pos)+6).."}")
                    elseif (type(val)=="string") then
                        print(indent.."['"..pos..'\'] => "'..val..'"')
                    else
                        print(indent.."['"..pos.."\'] => "..tostring(val))
                    end
                end
            else
                print(indent..tostring(t))
            end
        end
    end
    if (type(t)=="table") then
        print(tostring(t).." {")
        sub_print_r(t,"  ")
        print("}")
    else
        sub_print_r(t,"  ")
    end
    print()
end


function DEBUGPrintNotecardPos()
    print_r(playerInformation['purple']['Equipoment'].getPosition())
    for i=1,5 do
        print_r(playerInformation['purple']['Note'..i].getPosition())
    end
end
function DEBUGprintJournal()
    print_r(CharacterJournals)
end
function DEBUGprintPlayerInfo()
    print_r(playerInformation)
end

function getSeatedPlayersExcept(table)
    local result = getSeatedPlayers()
    return array_sub(table,result)
end
