zoneColor = {
    ['4201a1'] = 'Red',
    ['4201a2'] = 'Orange',
    ['4201a3'] = 'Yellow',
    ['4201a4'] = 'Green',
    ['4201a5'] = 'Blue',
    ['4201a9'] = 'Purple'
}

sheetPos = {
    ['Red'] = {-26.5910873,1.07,-40.87593},
    ['Orange'] = {19.4391747,1.07,-40.87593},
    ['Yellow'] = {58.7964745,1.07,-18.4719715},
    ['Green'] = {58.7964745,1.07,18.4564972},
    ['Blue'] = {19.4391747,1.07,40.87593},
    ['Purple'] = {-26.2886486,1.07,40.87593}
}

sheetRot = {
    ['Red'] = {0,180,0},
    ['Orange'] = {0,180,0},
    ['Yellow'] = {0,90,0},
    ['Green'] = {0,90,0},
    ['Blue'] = {0,0,0},
    ['Purple'] = {0,0,0}
}

playerInformation = {
    ['Red'] = {},
    ['Orange'] = {},
    ['Yellow'] = {},
    ['Green'] = {},
    ['Blue'] = {},
    ['Purple'] = {}
}

tabsYPos = {
    ['Red'] = {},
    ['Orange'] = {},
    ['Yellow'] = {},
    ['Green'] = {},
    ['Blue'] = {},
    ['Purple'] = {}
}

function onload(save_state)
    characterSheetSourceZone = getObjectFromGUID('9ba365')
    characterSheetSourcePlatform = getObjectFromGUID('f99d56')
    characterSheetSource = selectCharacterSheetSource(characterSheetSourceZone)

    if characterSheetSource ~= nil then
        setupNewCharacterSheetSource(characterSheetSource)
        Global.call('addButton',{characterSheetSourcePlatform.getGUID(), 900,150,80,'UnLoad Character Sheet','unloadCharacterSheetSource',self,{3.5,0.15,-1.8},{-30,0,0}})
        Global.call('addButton',{characterSheetSourcePlatform.getGUID(), 900,150,80,'New Journal','createBlankJournal',self,{3.5,0.15,-1.3},{-30,0,0}})
    else
        printToAll('Please load a character sheet. Try to have one loaded at all times.', {0,1,0})
        Global.call('addButton',{characterSheetSourcePlatform.getGUID(), 900,150,80,'Load Character Sheet','loadCharacterSheetSource',self,{3.5,0.15,-1.8},{-30,0,0}})
    end

    keyLookup = {}

    config = Global.getVar('config')
    tool = Global.getVar('tool')
    roll = Global.getVar('roll')

    currentPlayers = getSeatedPlayersExcept({'White'})

    if save_state == "[]" or save_state == "" then
        CharacterSheets = {}
        CharacterJournals = {}
        keyLookupGUID = {}
    else
        local function getObjectFromGUIDTable(e)
            local result = {}
            for key,guid in pairs(e) do
                if type(guid) == "table" then
                    result[key] = getObjectFromGUIDTable(guid)
                elseif type(guid) == "string" and getObjectFromGUID(guid) == nil then -- For scrollbar above&below information
                    result[key] = guid
                else
                    result[key] = getObjectFromGUID(guid)
                end
            end
            return result
        end

        local function convertIndexFromGUIDToObj(e)
            local result = {}
            if e ~= nil then
                for key,object in pairs(e) do
                    if type(object) == "table" then
                        result[key] = convertIndexFromGUIDToObj(object)
                    elseif type(key) == "string" then
                        result[getObjectFromGUID(key)] = object
                    end
                end
                return result
            else
                return nil
            end
        end

        local savedVars = JSON.decode(save_state)
        CharacterSheets   = getObjectFromGUIDTable(savedVars['CharacterSheets'])
        playerInformation = getObjectFromGUIDTable(savedVars['playerInformation'])
        CharacterJournals = getObjectFromGUIDTable(savedVars['CharacterJournals'])
        keyLookupGUID = savedVars['keyLookupGUID']
        tabsYPos = convertIndexFromGUIDToObj(savedVars['tabsYPos']) or tabsYPos
        -- Saving Safe
       for key,color in pairs(Global.getTable('colorTable')) do
           if next(playerInformation[color]) ~= nil then
               if not Player[color].seated then -- if theres info and is not seated, delete
                   if CharacterJournals[color] ~= nil then closeBook(color) end
                   destroyCharacterSheet(color)
               else -- there's info and someones seated - reassociate
                   tool.call('loadPlayer',{color})
                   local function deepInteractable(e)
                       for key,object in pairs(e) do
                           if type(object) == "table" then
                               deepInteractable(object)
                           elseif string.sub(tostring(object),1,-30) ~= "Notecard" then
                               object.interactable = false
                           end
                       end
                   end
                   --deepInteractable(playerInformation[color])
                   CharacterSheets[color]['interactable'] = false
                   Global.call('setZone',{color,1})
                   for index,value in pairs(playerInformation[color]['tabs']) do -- Iterate through Tabs and reset them to hidden positions.
                       CharacterSheets[color].setVar('currentTab',index)
                       resetTab(color)
                   end
               end
               if CharacterJournals[color] ~= nil then
                   enableManager(color)
                   Global.call('setZone',{color,2})
               end
           else
               if Player[color].seated and characterSheetSource ~= nil then -- if theres no info but someone is seated, spawn
                   initSheet(color)
               end
           end
       end -- for
    end
end

x = 0
function onSave()
    local savedVars = {}
    local function getGUIDFromObjectTable(e)
        local result = {}
        for key,object in pairs(e) do
            if type(object) == "table" then
                result[key] = getGUIDFromObjectTable(object)
            elseif type(object) == "string" and object.tag == nil then -- For scrollbar above&below information
                result[key] = object
            else
                result[key] = object.getGUID()
            end
        end
        return result
    end

    local function convertIndexFromObjToGUID(e)
        local result = {}
        for key,object in pairs(e) do
            if type(object) == "table" then
                result[key] = convertIndexFromObjToGUID(object)
            elseif type(key) == "userdata" then
                result[key.getGUID()] = object
            end
        end
        return result
    end

    savedVars['CharacterSheets'] = getGUIDFromObjectTable(CharacterSheets)
    savedVars['CharacterJournals'] = getGUIDFromObjectTable(CharacterJournals)
    savedVars['playerInformation'] = getGUIDFromObjectTable(playerInformation)
    savedVars['tabsYPos'] = convertIndexFromObjToGUID(tabsYPos)
    savedVars['keyLookupGUID'] = keyLookupGUID


    --if x==0 then print_r(savedVars) x=1 end
    return JSON.encode_pretty(savedVars)
end

function calculateLookup()
    lookupButtonData = {}
    local offsetListArray = {incrementalOffsetList,toggleOffsetList,checkboxOffsetList,tabsOffsetList}
    for index,offsetList in pairs(offsetListArray) do
        for key,value in pairs(offsetList) do
            local switch = {
                [1] = function() -- incrementalOffsetList
                    lookupButtonData[key]['1stPos'] = {value['mod'][1] + value['gap'][1],0,value['mod'][2] + value['gap'][2]}
                    lookupButtonData[key]['2ndPos'] = {value['mod'][1] - value['gap'][1],0,value['mod'][2] - value['gap'][2]}
                end,
                [2] = function() -- toggleOffsetList
                    lookupButtonData[key]['set'] = value['set']
                    lookupButtonData[key]['pos'] = {value['mod'][1],0,value['mod'][2]}
                end,
                [3] = function() -- checkboxOffsetList
                    lookupButtonData[key]['gap'] = value['gap']
                    lookupButtonData[key]['pos'] = {value['mod'][1],0,value['mod'][2]}
                    local iterator = 0
                    for i,v in pairs(value['listVariables']) do
                        self.setVar('lookupButtonData'..key..i,function(obj,color) modifierCheckbox(obj,color,v) end)
                        iterator = iterator + 1
                    end
                    lookupButtonData[key]['listSize'] = iterator
                end,
                [4] = function() -- tabsOffsetList
                    lookupButtonData[key]['pos'] = {value['mod'][1],0,value['mod'][2]}
                end
            }
            lookupButtonData[key] = {}
            lookupButtonData[key]['modSize'] = value['modSize'] or 200
            lookupButtonData[key]['triggerUpdate'] = value['triggerUpdate'] or false
            switch[index]()
        end
    end
end

function selectCharacterSheetSource(zone)
    for index,source in pairs(zone.getObjects()) do
        if source.getVar('uniqueID') ~= nil then
            source['interactable'] = false
            return source
        end
    end
    print('No character sheet source found! Please select a character sheet!')
    return nil
end

function setupNewCharacterSheetSource(source)
    customSheetData = source.getTable('customSheetData') or {}
    DM_Visible_Stats = source.getTable('DM_Visible_Stats') or {}
    objectOffsetList = source.getTable('objectOffsetList') or {}
    incrementalOffsetList = source.getTable('incrementalOffsetList') or {}
    toggleOffsetList = source.getTable('toggleOffsetList') or {}
    checkboxOffsetList = source.getTable('checkboxOffsetList') or {}
    textOffsetList = source.getTable('textOffsetList') or {}
    inertOffsetList = source.getTable('inertOffsetList') or {}
    tabsOffsetList = source.getTable('tabsOffsetList') or {}
    calculateLookup()
end

function loadCharacterSheetSource()
    if characterSheetSource == nil then
        characterSheetSource = selectCharacterSheetSource(characterSheetSourceZone)
        if characterSheetSource ~= nil then
            setupNewCharacterSheetSource(characterSheetSource) -- load custom sheet info
            -- Iterate through players and initialize their sheets
            for key,color in pairs(Global.getTable('colorTable')) do
                if Player[color].seated then
                    initSheet(color)
                end
            end
            printToAll(characterSheetSource.getName()..' is now active!', {0,1,0})

            local params = {
                ['index'] = 0,
                ['click_function'] = 'unloadCharacterSheetSource',
                ['label'] = 'Unload Character Sheet'
            }
            characterSheetSourcePlatform.editButton(params)
            Global.call('addButton',{characterSheetSourcePlatform.getGUID(), 900,150,80,'New Journal','createBlankJournal',self,{3.5,0.15,-1.3},{-30,0,0}})
        end
    else
        print('No character sheet source found.')
    end
end

function unloadCharacterSheetSource()
    if characterSheetSource ~= nil then
        -- Iterate through players and destroy their sheets
        for key,color in pairs(Global.getTable('colorTable')) do
            if next(playerInformation[color]) ~= nil then
                if Player[color].seated then
                    destroyCharacterSheet(color)
                end
            end
        end
        characterSheetSource['interactable'] = true
        characterSheetSource.translate({4,0,0})
        characterSheetSource = nil

        printToAll('Character sheet unloaded. Please load a new one.', {0,1,0})

        local params = {
            ['index'] = 0,
            ['click_function'] = 'loadCharacterSheetSource',
            ['label'] = 'Load Character Sheet'
        }
        characterSheetSourcePlatform.editButton(params)
        characterSheetSourcePlatform.removeButton(1)
    end
end

function initSheet(color)
    keyLookup[color] = {}
    playerInformation[color]['edit'] = {}
    playerInformation[color]['edit']['incremental'] = {}
    playerInformation[color]['edit']['incremental']['alwaysVisible'] = {}
    playerInformation[color]['edit']['toggle'] = {}
    playerInformation[color]['edit']['toggle']['alwaysVisible'] = {}
    playerInformation[color]['edit']['checkbox'] = {}
    playerInformation[color]['edit']['checkbox']['alwaysVisible'] = {}
    playerInformation[color]['edit']['tabs'] = {}
    playerInformation[color]['edit']['tabs']['alwaysVisible'] = {}
    playerInformation[color]['scrollbars'] = {}
    playerInformation[color]['tabs'] = {}
    playerInformation[color]['tabModifiers'] = {}
    for tabName,value in pairs(tabsOffsetList) do -- Initialize tables for tabs and tab modifiers
        playerInformation[color]['tabModifiers'][tabName] = {}
        playerInformation[color]['tabModifiers'][tabName]['alwaysVisible'] = {}
        playerInformation[color]['tabs'][tabName] = {}
    end
    tabsYPos[color] = {}

    local sheet = spawnObject({
        ['type'] = 'Custom_Model',
        ['position'] = sheetPos[color],
        ['rotation'] = sheetRot[color]
    })

    sheet.setCustomObject(customSheetData) -- Taking the spawning information from the character sheet source.
    sheet['interactable'] = false
    sheet.setName(color.."CS")
    sheet.setLock(true)
    CharacterSheets[color] = sheet

    local offsetArray = {objectOffsetList,textOffsetList,inertOffsetList,incrementalOffsetList,toggleOffsetList,checkboxOffsetList,tabsOffsetList}
    for index,offsetList in ipairs(offsetArray) do
        local position = {}
        local rotation = {}
        local obj
        for key,value in pairs(offsetList) do
            rotation = value['rotation'] or {0,0,0}
            if color == 'Purple' or color == 'Blue' then
                position = {sheetPos[color][1] + value[1],1.08,sheetPos[color][3] + value[2]}
                rotation = {(90 + rotation[1])%360,(180 + rotation[2])%360,(0 + rotation[3])%360}
            elseif color == 'Red' or color == 'Orange' then
                position = {sheetPos[color][1] - value[1],1.08,sheetPos[color][3] - value[2]}
                rotation = {(90 + rotation[1])%360,(0 + rotation[2])%360,(0 + rotation[3])%360}
            elseif color == 'Yellow' or color == 'Green' then
                position = {sheetPos[color][1] + value[2],1.08,sheetPos[color][3] - value[1]}
                rotation = {(90 + rotation[1])%360,(270 + rotation[2])%360,(0 + rotation[3])%360}
            end

            if index > 1 then -- Avoid spawning objects as textools
                local tabPosition = position
                if value['tab'] ~= nil then -- preparing to hide the object if it's supposed to part of a 'tab'
                    tabPosition = {position[1],position[2]-5,position[3]}
                end
                obj = spawnObject({
                    ['type'] = '3DText',
                    ['position'] = tabPosition
                })
                obj.setRotationSmooth(rotation)
                obj.TextTool.setFontSize(value['size'] or 64)
                obj.TextTool.setFontColor(returnColorTable(value['color'] or 'Grey'))
                obj.TextTool.setValue(value['text'] or ' ')
                obj['interactable'] = false
            end
            local switch = {
                [1] = function () -- objects
                    if value['tab'] ~= nil then
                        position[2] = position[2] - 6.08 + value['height'] -- adjusting user set height against base text tool height
                    else
                        position[2] = value['height']
                    end
                    obj = spawnObject({
                        ['type'] = value['type'],
                        ['position'] = position,
                        ['rotation'] = rotation
                    })
                    obj.setName(value['name'] or '')
                    obj.setScale({value['scale'],value['scale'],value['scale']})
                    obj.setColorTint(returnColorTable(value['color'] or 'Grey'))
                    obj.setLock(true)
                    if value['tab'] ~= nil then
                        obj['interactable'] = false
                    end
                end,
                [2] = function() -- text, inert
                    if value['color'] == true then obj.TextTool.setFontColor(returnColorTable(color)) end
                end,
                [3] = function() -- incremental, toggle, checkbox, tabs
                    local modifier = spawnObject({
                        ['type'] = 'Custom_Model',
                        ['position'] = position,
                        ['rotation'] = {rotation[1]-270,rotation[2],0}
                    })
                    modifier.setColorTint({0,0,0})
                    modifier.setCustomObject({['mesh'] = 'http://pastebin.com/raw/yteXiDWq'})
                    modifier.setLock(true)
                    local offsetNames = {'incremental','toggle','checkbox','tabs'}
                    if value['alwaysVisible'] == true then
                        playerInformation[color]['edit'][offsetNames[index-3]]['alwaysVisible'][key] = modifier
                        if value['tab'] ~= nil then
                            playerInformation[color]['tabModifiers'][value['tab']]['alwaysVisible'][key] = modifier
                            modifier.setScale({0,0,0}) -- Always visible tab buttons are activated with the tab's button
                        end
                    else
                        playerInformation[color]['edit'][offsetNames[index-3]][key] = modifier
                        modifier.setScale({0,0,0})
                        if value['tab'] ~= nil then
                            playerInformation[color]['tabModifiers'][value['tab']][key] = modifier
                        end
                    end
                    keyLookup[color][obj] = modifier
                end
            }
            if index == 1 then -- Validate Execution
                switch[1]()
            elseif index == 2 or index == 3 then
                switch[2]()
            elseif index >= 4 and index <= 7 then
                switch[3]()
            else
                print('Failure to load all offset tables. Please revise your custom character sheet code.')
            end
            if value['tab'] ~= nil then
                playerInformation[color]['tabs'][value['tab']][key] = obj -- With this, items belonging to tabs are saved in both the main item directory, meaning playerInformation[color][key], as well as this new one. Functional, but inefficient.
                if index == 1 then
                    tabsYPos[color][obj] = position[2] -- Create an object based table to store the original Y positions of tab objects
                else
                    tabsYPos[color][obj] = -3.92 -- Create an object based table to store the original Y positions of tab objects
                end
            end
            playerInformation[color][key] = obj
        end
    end
    Timer.create({
        ['identifier'] = 'initPlayer'..color,
        ['function_name'] = 'initPlayer',
        ['function_owner'] = self,
        ['parameters'] = {color},
        ['delay'] = 0.2
    })
end

function initPlayer(color) -- Receives Table
    color = color[1]
    -- Executes 1 second after everything in a char sheet is spawned
    keyLookupGUID[color] = {}
    for key,value in pairs(keyLookup[color]) do
        keyLookupGUID[color][key.getGUID()] = value.getGUID()
    end
    tool.call('loadPlayer',{color})
    Global.call('setZone',{color,1})
end

-- Triggered when valid book enters available zone - called from onObjectEnterScriptingZone
function loadCharacter(arg)
    local enter_object = arg[1]
    local zone = arg[2]
    local color = arg[3]
    openBook(enter_object,zone)
    enableManager(color)
end


function openBook(book,zone)
    local param = book.getCustomObject()
    param['mesh'] = 'http://pastebin.com/raw/YTsHZRfG'
    param['diffuse'] = 'http://i.imgur.com/XgSo3GV.png'
    local obj = spawnObject({
        type = 'Custom_Model',
        position = zone.getPosition(),
        rotation = zone.getRotation()
    })
    obj.setCustomObject(param)

    local code = book.getLuaScript()
    obj.setLuaScript(code)
    obj.setVar('open', 1)
    obj['interactable'] = false
    obj.setLock(true)
    CharacterJournals[keyFromValue(Global.getTable('zoneFromColor'),zone.guid)] = obj
    readFromBook(keyFromValue(Global.getTable('zoneFromColor'),zone.guid),book)
    book.destruct()
end

function enableManager(color)
    -- This funciton enables buttons

    -- Called when:
    -- 1) A character has finished loading, after open Book.
    -- 2) A rewind/reload was made and sheet needs buttons.

    local function createScrollbarButtonsFromTable(table)
        for key,object in pairs(table) do
            if object['type'] == 'Notecard' and object['scrollbar'] == true then
                Global.call('addButton',{playerInformation[color][key].getGUID(), 40,40,70,string.char(9662),'scrollUp',self,{-0.46,5,0.45},{0,0,0}})
                Global.call('addButton',{playerInformation[color][key].getGUID(), 40,40,70,string.char(9652),'scrollDown',self,{-0.46,5,-0.45},{0,0,0}})
            end
        end
    end

    local function createIncrementButtonsFromTable(table)
        for key,object in pairs(table) do
            if type(object) == 'table' then
                createIncrementButtonsFromTable(object)
            else
                local modSize = lookupButtonData[key]['modSize']
                Global.call('addButton',{object.getGUID(),modSize,modSize,modSize,'-','modifierSub',self,lookupButtonData[key]['1stPos']})
                Global.call('addButton',{object.getGUID(),modSize,modSize,modSize,'+','modifierAdd',self,lookupButtonData[key]['2ndPos']})
            end
        end
    end

    local function createToggleButtonsFromTable(table)
        for key,object in pairs(table) do
            if type(object) == 'table' then
                createToggleButtonsFromTable(object)
            else
                local modSize = lookupButtonData[key]['modSize']
                Global.call('addButton',{object.getGUID(),modSize,modSize,modSize,' ','modifierToggle',self,lookupButtonData[key]['pos']})
            end
        end
    end

    local function createCheckboxButtonsFromTable(table)
        for key,object in pairs(table) do
            if type(object) == 'table' then
                createCheckboxButtonsFromTable(object)
            else
                local modSize = lookupButtonData[key]['modSize']
                local pos = lookupButtonData[key]['pos']
                for i=1,lookupButtonData[key]['listSize'] do
                    pos = {pos[1] + lookupButtonData[key]['gap'][1],0,pos[3] + lookupButtonData[key]['gap'][2]}
                    Global.call('addButton',{object.getGUID(),modSize,modSize,modSize,'x','lookupButtonData'..key..i,self,pos})
                end
            end
        end
    end

    local function createTabsButtonsFromTable(table)
        for key,object in pairs(table) do
            if type(object) == 'table' then
                createTabsButtonsFromTable(object)
            else
                local modSize = lookupButtonData[key]['modSize']
                Global.call('addButton',{object.getGUID(),modSize,modSize,modSize,' ','modifierTabs',self,lookupButtonData[key]['pos']})
            end
        end
    end

    Global.call('addButton', {CharacterSheets[color].getGUID(),3000,500,350,'Spawn Figurine','spawnFigurine',self,{13.2,0.01,-2.3}})
    Global.call('addButton', {CharacterSheets[color].getGUID(),3000,500,350,'Link Figurine','linkFigurine',self,{13.2,0.01,-1.0}})
    Global.call('addButton', {CharacterSheets[color].getGUID(),3000,500,350,'Reserved','reservedButton',self,{13.2,0.01,0.3}})
    Global.call('addButton', {CharacterSheets[color].getGUID(),3000,500,350,'Reserved','reservedButton',self,{13.2,0.01,1.6}})
    Global.call('addButton', {CharacterSheets[color].getGUID(),3000,500,350,'Reserved','reservedButton',self,{13.2,0.01,2.9}})
    Global.call('addButton', {CharacterSheets[color].getGUID(),3000,500,350,'Reserved','reservedButton',self,{13.2,0.01,4.2}})
    Global.call('addButton', {CharacterSheets[color].getGUID(),3000,500,350,'Edit Sheet','toggleEdit',self,{13.2,0.01,5.5}})
    Global.call('addButton', {CharacterSheets[color].getGUID(),3000,600,350,'Save & Close','saveCharacter',self,{13.2,0.01,7.2}})
    createScrollbarButtonsFromTable(objectOffsetList)
    createIncrementButtonsFromTable(playerInformation[color]['edit']['incremental'])
    createToggleButtonsFromTable(playerInformation[color]['edit']['toggle'])
    createCheckboxButtonsFromTable(playerInformation[color]['edit']['checkbox'])
    createTabsButtonsFromTable(playerInformation[color]['edit']['tabs'])
end

function disableManager(color) -- removes most buttons from the character sheet
    -- called when closing a character journal
    local function deleteScrollbarButtonsFromTable(table)
        for key,object in pairs(table) do
            if object['type'] == 'Notecard' and object['scrollbar'] == true then
                playerInformation[color][key].clearButtons()
            end
        end
    end

    local function deleteCheckboxButtonsFromTable(table)
        for key,object in pairs(table) do
            if type(object) == 'table' then
                deleteCheckboxButtonsFromTable(object)
            else
                for i=1,lookupButtonData[key]['listSize'] do
                    object.clearButtons()
                end
            end
        end
    end

    local function deleteGenericButtonsFromTable(table) -- used for increment, toggle and tabs buttons
        for key,object in pairs(table) do
            if type(object) == 'table' then
                deleteGenericButtonsFromTable(object)
            else
                object.clearButtons()
            end
        end
    end

    CharacterSheets[color].clearButtons() -- clear the right hand manager panel
    deleteScrollbarButtonsFromTable(objectOffsetList)
    deleteCheckboxButtonsFromTable(playerInformation[color]['edit']['checkbox'])
    for i,v in pairs({playerInformation[color]['edit']['incremental'], playerInformation[color]['edit']['toggle'], playerInformation[color]['edit']['tabs']}) do
        deleteGenericButtonsFromTable(v)
    end
end

function toggleEdit(obj,color)
    -- TODO: Validate that player clicking is the owner of the sheet

    local labels = {'Edit Sheet','Exit Edit Mode'}
    --local msg = {DA.."Edit Mode is now off.",DA.."You are now editing your sheet. To Finish editing, Press \"Exit Edit Mode\""}
    local x = 1 - (obj.getVar('editMode') or 0)
    obj.setVar('editMode', x)
    params = obj.getButtons()
    params[7]['label'] = labels[x+1]
    --printToColor(msg[x+1],player,{0.2,0.8,0.8})
    obj.editButton(params[7])
    local offsetNames = {'incremental','toggle','checkbox','tabs'}

    local action = {
        [0] = function() -- Edit mode OFF
            for i=1,4 do
                for index,modifier in pairs(playerInformation[color]['edit'][offsetNames[i]]) do
                    if type(modifier) ~= 'table' then
                        modifier.setScale({0,0,0})
                    end
                end
            end
            for key,_ in pairs(textOffsetList) do
                playerInformation[color][key]['interactable'] = false
            end
        end,
        [1] = function() -- Edit mode ON
            for i=1,4 do
                for _,object in pairs(playerInformation[color]['edit'][offsetNames[i]]) do
                    if type(object) ~= 'table' then
                        object.setScale({1,1,1})
                    end
                end
            end
            for tab,_ in pairs(tabsOffsetList) do -- disable non-currentTab tab items.
                if obj.getVar('currentTab') ~= tab then
                    for index,modifier in pairs(playerInformation[color]['tabModifiers'][tab]) do
                        if type(modifier) ~= 'table' then
                            modifier.setScale({0,0,0})
                        end
                    end
                end
            end
            for key,_ in pairs(textOffsetList) do
                playerInformation[color][key]['interactable'] = true
            end
        end
    }
    action[x]()
end

function spawnFigurine(obj,color)
    printToColor('This feature is not available yet, but we are working on it!',color,{0,1,0})
end

function linkFigurine(obj,color)
    printToColor('This feature is not available yet, but we are working on it!',color,{0,1,0})
end

function reservedButton(obj,color)
    printToColor('This button doesn\'t have a purpose yet. Have ideas? Let us know on the workshop or on Discord!',color,{0,1,0})
end

function modifierAdd(obj,color) -- Called from a + incremental button
    local targetGUID = keyFromValue(keyLookupGUID[color],obj.guid)
    if targetGUID ~= nil then
        local counter = getObjectFromGUID(targetGUID)
        local key = keyFromValue(playerInformation[color],counter)
        local newValue
        newValue = CharacterJournals[color].getVar(key) or 0
        newValue = newValue + 1
        CharacterJournals[color].setVar(key,newValue)
        counter.TextTool.setValue(tostring(newValue))
        if lookupButtonData[key]['triggerUpdate'] == true then characterSheetSource.call('calculateCharacterSheetValues',{color}) end
    else
        printToColor('Either the object does not exist or you do not own this sheet! Try reloading the sheet.',color,{0.3,0,0})
    end
end

function modifierSub(obj,color) -- Called from a - incremental button
    local targetGUID = keyFromValue(keyLookupGUID[color],obj.guid)
    if targetGUID ~= nil then
        local counter = getObjectFromGUID(targetGUID)
        local key = keyFromValue(playerInformation[color],counter)
        local newValue
        newValue = CharacterJournals[color].getVar(key) or 0
        newValue = newValue - 1
        CharacterJournals[color].setVar(key,newValue)
        counter.TextTool.setValue(tostring(newValue))
        if lookupButtonData[key]['triggerUpdate'] == true then characterSheetSource.call('calculateCharacterSheetValues',{color}) end
    else
        printToColor('Either the object does not exist or you do not own this sheet! Try reloading the sheet.',color,{0.3,0,0})
    end
end

function modifierToggle(obj,color) -- Called from a toggle button
    local targetGUID = keyFromValue(keyLookupGUID[color],obj.guid)
    if targetGUID ~= nil then
        local toggle = getObjectFromGUID(targetGUID)
        local key = keyFromValue(playerInformation[color],toggle)
        local index = keyFromValue(lookupButtonData[key]['set'],CharacterJournals[color].getVar(key))
        local newValue = lookupButtonData[key]['set'][next(lookupButtonData[key]['set'],index)] or lookupButtonData[key]['set'][1]
        CharacterJournals[color].setVar(key,newValue)
        toggle.TextTool.setValue(newValue)
        if lookupButtonData[key]['triggerUpdate'] == true then characterSheetSource.call('calculateCharacterSheetValues',{color}) end
    else
        printToColor('Either the object does not exist or you do not own this sheet! Try reloading the sheet.',color,{0.3,0,0})
    end
end

function modifierCheckbox(obj,color,element) -- Called from a checkbox button
    if tonumber(element) then print('Invalid checkbox element, do not use numbers as strings in the set. Edit your custom sheet.')
    else
        local targetGUID = keyFromValue(keyLookupGUID[color],obj.guid)
        if targetGUID ~= nil then
            local checkbox = getObjectFromGUID(targetGUID)
            local key = keyFromValue(playerInformation[color],checkbox)
            local workTable = CharacterJournals[color].getTable(key)
            workTable[element] = not workTable[element]
            CharacterJournals[color].setTable(key,workTable)
            checkbox.TextTool.setValue(getProficienciesString(color,key))
            if lookupButtonData[key]['triggerUpdate'] == true then characterSheetSource.call('calculateCharacterSheetValues',{color}) end
        else
            printToColor('Either the object does not exist or you do not own this sheet! Try reloading the sheet.',color,{0.3,0,0})
        end
    end
end

function modifierTabs(obj,color) -- Called from a tab button
    local targetGUID = keyFromValue(keyLookupGUID[color],obj.guid)
    if targetGUID ~= nil then
        local tab = getObjectFromGUID(targetGUID)
        local key = keyFromValue(playerInformation[color],tab)
        local currentTab = CharacterSheets[color].getVar('currentTab') or 'none'
        if currentTab ~= key then -- reset to default position where no tab is active
            resetTab(color)
            for index,obj in pairs(playerInformation[color]['tabs'][key]) do
                local pos = obj.getPosition()
                obj.setPosition({pos[1],tabsYPos[color][obj]+5,pos[3]})
                obj['interactable'] = true
            end
            CharacterSheets[color].setVar('currentTab',key)
            for index,modifier in pairs(playerInformation[color]['tabModifiers'][key]['alwaysVisible']) do
                modifier.setScale({1,1,1}) -- Activate always visible buttons related ot the current tab
            end
            toggleEdit(CharacterSheets[color],color) -- Reset the state of edit mode to prevent lingering buttons
            toggleEdit(CharacterSheets[color],color)
        end
        if lookupButtonData[key]['triggerUpdate'] == true then characterSheetSource.call('calculateCharacterSheetValues',{color}) end
    else
        printToColor('Either the object does not exist or you do not own this sheet! Try reloading the sheet.',color,{0.3,0,0})
    end
end

function resetTab(color) -- moves all tab objects beneath the table
    local currentTab = CharacterSheets[color].getVar('currentTab') or 'none'
    if currentTab ~= 'none' then
        for i,obj in pairs(playerInformation[color]['tabs'][currentTab]) do
            local pos = obj.getPosition()
            obj.setPosition({pos[1],tabsYPos[color][obj],pos[3]})
            obj['interactable'] = false
        end
        for index,modifier in pairs(playerInformation[color]['tabModifiers'][currentTab]['alwaysVisible']) do
            modifier.setScale({0,0,0}) -- Activate always visible buttons related ot the current tab
        end
        CharacterSheets[color].setVar('currentTab','none')
    end
end

function readFromBook(color,journal)
    local offsetArray = {toggleOffsetList, textOffsetList, inertOffsetList}
    for index,offset in pairs(offsetArray) do
        for key,value in pairs(offset) do
            CharacterJournals[color].setVar(key,journal.getVar(key))
            playerInformation[color][key].TextTool.setValue(tostring(journal.getVar(key)))
        end
    end
    for key,value in pairs(incrementalOffsetList) do
        CharacterJournals[color].setVar(key,journal.getVar(key))
        playerInformation[color][key].TextTool.setValue(tostring(journal.getVar(key)))
    end

    for key,value in pairs(checkboxOffsetList) do
        CharacterJournals[color].setTable(key, journal.getTable(key))
        playerInformation[color][key].TextTool.setValue(getProficienciesString(color,key))
    end

    for key,value in pairs(objectOffsetList) do
        if value['type'] ~= 'Notecard' then
            CharacterJournals[color].setVar(key,journal.getVar(key))
            playerInformation[color][key].setValue(journal.getVar(key))
            playerInformation[color][key].setName(value['name'])
        elseif value['name'] ~= 'Inventory' then
            CharacterJournals[color].setVar(key,journal.getVar(key))
            playerInformation[color][key].setName(value['name'])
            if value['scrollbar'] == true then -- setup the above and below variables
                local text = journal.getVar(key) or ''
                local newPage = tool.call('getPageAccessor',{text})
                if type(newPage) == 'table' then -- Checking for unidentified characters
                    playerInformation[color]['scrollbars'][key] = {}
                    playerInformation[color]['scrollbars'][key]['above'] = ''
                    playerInformation[color]['scrollbars'][key]['below'] = ''
                    playerInformation[color]['scrollbars'][key]['starting'] = ''
                    if CharacterSheets[color].getVar('wipeCorruptedNotecards') == true then
                        printToColor('Deleting broken notecard: '..value['name'],color,{1,0.3,0.3})
                        playerInformation[color][key].setDescription('')
                    else
                        playerInformation[color][key].setDescription(text)
                        printToColor('Uh oh! The notecard named "'..value['name']..'" was saved with the unrecognized character/letter "'..newPage[1]..'"',color,{1,0.3,0.3})
                        printToColor('Force closing the journal to prevent data loss. Please open the LUA script of this journal in single player and remove the unrecognized character/letter!',color,{1,0.3,0.3})
                        printToColor('Alternatively, quickly load this journal again if you want to erase the broken notecard completely -- your data will be lost!',color,{1,0.3,0.3})
                        printToColor('\nCharacter Sheet is now in "Erase Corrupted Notecards" mode.',color,{1,0.3,0.3})

                        Timer.create({
                            ['identifier'] = 'forceCloseJournal'..color..math.random(1000),
                            ['function_name'] = 'saveCharacterAccessor',
                            ['function_owner'] = self,
                            ['parameters'] = {color},
                            ['delay'] = 3
                        })
                        CharacterSheets[color].setVar('wipeCorruptedNotecards',true)
                        Timer.create({
                            ['identifier'] = 'returnFromEraseModeCharacterSheet'..color..math.random(1000),
                            ['function_name'] = 'disableEraseMode',
                            ['function_owner'] = self,
                            ['parameters'] = {color},
                            ['delay'] = 15
                        })
                    end
                else
                    playerInformation[color][key].setDescription(newPage)
                    playerInformation[color]['scrollbars'][key] = {}
                    playerInformation[color]['scrollbars'][key]['above'] = ''
                    playerInformation[color]['scrollbars'][key]['below'] = tool.call('removeNewlineAccessor',{tool.call('removeNewlineAccessor',{tool.call('plainReplaceAccessor',{text,newPage,''}),'Beginning'}),'Ending'})
                    playerInformation[color]['scrollbars'][key]['starting'] = playerInformation[color][key].getDescription()
                end
            else
                playerInformation[color][key].setDescription(journal.getVar(key))
            end
        end
        journal.setVar('wipeCorruptedNotecards',false)
    end

    tool.call('setupNewInventory',{color,journal.getVar('Inventory')})

    getObjectFromGUID(color.."NameDisplay").TextTool.setValue(journal.getVar('Character_Name')) -- Will this work in custom?

    local DMCounter = getObjectFromGUID(tool.getTable('DMHealthCounterGUIDs')[keyFromValue(Global.getVar('colorTable'),color)])
    DMCounter.setName(journal.getVar('Character_Name').."'s Health")
    DMCounter.Counter.setValue(journal.getVar('HP'))
    playerInformation[color]['HP'].Counter.setValue(journal.getVar('HP'))

    characterSheetSource.call('calculateCharacterSheetValues',{color})
end

function disableEraseMode(table) -- Timer function that stops CS from erasing corrupted notecards, table only contains color
    if CharacterSheets[table[1]] ~= nil then
        if CharacterSheets[table[1]].getVar('wipeCorruptedNotecards') == true then
            printToColor('Character sheet returning to normal. No longer in "Erase Corrupted Notecards" mode.',table[1],{1,0.3,0.3})
            CharacterSheets[table[1]].setVar('wipeCorruptedNotecards',false)
        end
    end
end

function saveCharacter(obj,color)
    if obj.getVar('editMode') == 1 then -- Set edit buttons back to default.
        toggleEdit(obj,color) -- moves invisible modifier objects beneath the table
    end
    disableManager(color) -- deletes buttons
    resetTab(color) -- moves all tab objects beneath the table
    closeBook(color) -- save character data
    cleanText(color) -- sets Text Tools to empty
    -- destruct figurine
    Global.call('setZone',{color,1}) -- on book exit - change zone to 1
end

function saveCharacterAccessor(table) -- table only contains color
    if CharacterJournals[table[1]] ~= nil then
        saveCharacter(CharacterSheets[table[1]],table[1])
    end
end

function closeBook(color) -- Destroys open book model, creates new closed book model which holds character data from the character sheet
    local param = CharacterJournals[color].getCustomObject()
    local pos = CharacterJournals[color].getPosition()
    if color == 'Blue' or color == 'Purple' then
        pos = {pos[1],pos[2],pos[3]+7}
    elseif color == 'Green' or color == 'Yellow' then
        pos = {pos[1]+7,pos[2],pos[3]}
    elseif color == 'Red' or color == 'Orange' then
        pos = {pos[1],pos[2],pos[3]-7}
    end
    local obj_param = {
        ['type'] = 'Custom_Model',
        ['position'] = pos,
        ['rotation'] = CharacterJournals[color].getRotation(),
    }

    local obj = spawnObject(obj_param)
    param["mesh"] = "http://pastebin.com/raw/y4hs8Riy"
    param["diffuse"] = "http://i.imgur.com/eT6yiIu.png"
    obj.setCustomObject(param)

    obj.setLuaScript(encodeBook(color)) -- creates the lua script and assigns it to the closed book
    destroyObject(CharacterJournals[color])
    CharacterJournals[color] = nil
end

function destroyCharacterSheet(color)
    if Global.call('getZone',{color}) == 2 then
        closeBook(color)
    end
    cleanText(color)
    CharacterSheets[color].destruct() -- Sheet Itself
    CharacterSheets[color] = nil
    destroyObjects(playerInformation[color])
    for k in pairs(keyLookupGUID[color]) do keyLookupGUID[color][k] = nil end
    keyLookupGUID[color] = nil
    tabsYPos[color] = nil
    Global.call('setZone',{color,0})
    getObjectFromGUID("TOOLS").call('removePlayerButton',{color})
end

function destroyObjects(table)
    for key,value in pairs(table) do
        if type(value) == 'userdata' then
            value.destruct()
        --else destroyObjects(value)
        elseif type(value) == "table" then
            destroyObjects(value)
        end
        table[key] = nil
    end
end

function cleanText(color) -- sets text tools to empty and counters to zero
    local offsetArray = {incrementalOffsetList,toggleOffsetList,checkboxOffsetList,textOffsetList,inertOffsetList}
    for index,offset in pairs(offsetArray) do
        for key,value in pairs(offset) do
            playerInformation[color][key].TextTool.setValue(' ')
        end
    end

    for key,value in pairs(objectOffsetList) do
        if value['type'] ~= 'Notecard' then
            playerInformation[color][key].setValue(0)
            playerInformation[color][key].setName('')
        else
            playerInformation[color][key].setDescription('')
            playerInformation[color][key].setName('')
        end
    end

    local DMCounter = getObjectFromGUID(tool.getTable('DMHealthCounterGUIDs')[keyFromValue(Global.getVar('colorTable'),color)])
    DMCounter.setName(' ')
    DMCounter.Counter.setValue(0)
    playerInformation[color]['HP'].Counter.setValue(0)

    getObjectFromGUID(color.."NameDisplay").TextTool.setValue(' ')
end

function onPlayerChangedColor(color)
    local oldColor = {}
    local holdPlayers = getSeatedPlayersExcept({'White',color})
    oldColor = array_sub(holdPlayers,currentPlayers)
    if color == 'Grey' then
        if oldColor[1] ~= 'White' and oldColor[1] ~= nil then
            destroyCharacterSheet(oldColor[1])
        end
    else
        if color ~= 'Black' then
            if color ~= 'White' and characterSheetSource ~= nil then
                initSheet(color)
            end
        else
            print("[0ff4f0]PLEASE USE WHITE AS COLOR TO DM")
        end
        if oldColor[1] != 'White' and oldColor[1] ~= nil then
            destroyCharacterSheet(oldColor[1])
        end
            --pActiveZoneArray[getZoneGUIDFromColor(color)] = 1
    end
    currentPlayers = getSeatedPlayersExcept({'White'})
end

function encodeBook(color) -- when saving a character journal creates the new script using the data on the character sheet
    local script = [[-- Quality RPG CHARACTER SAVE
-- ]].. os.date("Saved %X UTC ~ %a %d, %B %Y")..'\nuniqueID = \''..characterSheetSource.getVar('uniqueID')..'\'\nQRPGVersion = '..Global.getVar('QRPGVersion')

script = script..'\n\n--------------------------- Character Information ---------------------------\n'

    for key,value in pairs(objectOffsetList) do
        if value['type'] ~= 'Notecard' then
            script = script..'\n'..key..' = '..playerInformation[color][key].getValue()
        else
            if value['scrollbar'] == true then
                script = script..'\n'..key..' = \[\['..getFullText(color,key)..'\]\]'
            else
                script = script..'\n'..key..' = \[\['..playerInformation[color][key].getDescription()..'\]\]'
            end
        end
    end

    script = script..'\n\n'
    for key,value in pairs(incrementalOffsetList) do
        script = script..'\n'..key..' = '..CharacterJournals[color].getVar(key)
    end

    for key,value in pairs(toggleOffsetList) do
        if tonumber(CharacterJournals[color].getVar(key)) then
            script = script..'\n'..key..' = '..CharacterJournals[color].getVar(key)
        else
            script = script..'\n'..key..' = \[\['..tostring(CharacterJournals[color].getVar(key))..'\]\]'
        end
    end

    for key,value in pairs(checkboxOffsetList) do
        script = script..'\n'..key..' = {'
        for i,v in pairs(CharacterJournals[color].getTable(key)) do
            if tonumber(i) then
                script = script..'\n\t['..i..'] = '..tostring(v)..','
            else
                script = script..'\n\t[\"'..i..'\"] = '..tostring(v)..','
            end
        end
        script = string.sub(script,1,-2)
        script = script..'\n}\n'
    end

    local offsetArray = {textOffsetList, inertOffsetList}
    for i,v in pairs(offsetArray) do
        for key,value in pairs(v) do
            script = script..'\n'..key..' = \[\['..tostring(playerInformation[color][key].getValue())..'\]\]'
        end
    end

    script = script..'\n\nfunction onLoad(save_state)\n\tself.setName(Character_Name)\n\tself.setDescription("QRPG Character Save")\nend'

    return script
end

function createBlankJournal()
    if characterSheetSource ~= nil then
        local pos = characterSheetSourcePlatform.getPosition()
        local obj_param = {
            ['type'] = 'Custom_Model',
            ['position'] = {pos[1]-3,pos[2]+1,pos[3]+2},
            ['rotation'] = {0,90,0}
        }
        local obj = spawnObject(obj_param)

        local custom_param = {
            ['mesh'] = 'http://pastebin.com/raw/y4hs8Riy',
            ['diffuse'] = 'http://i.imgur.com/eT6yiIu.png',
            ['material'] = 3,
            ['specular_intensity'] = 0,
            ['specular_sharpness'] = 2,
            ['fresnel_strength'] = 0
        }
        obj.setCustomObject(custom_param)

        local script = [[-- Quality RPG CHARACTER SAVE
    -- ]].. os.date("Saved %X UTC ~ %a %d, %B %Y")..'\nuniqueID = \''..characterSheetSource.getVar('uniqueID')..'\'\nQRPGVersion = '..Global.getVar('QRPGVersion')

    script = script..'\n\n--------------------------- Character Information ---------------------------\n'

        for key,value in pairs(objectOffsetList) do
            if value['type'] ~= 'Notecard' then
                script = script..'\n'..key..' = '..0
            else
                script = script..'\n'..key..' = \[\[\]\]'
            end
        end

        script = script..'\n\n'
        for key,value in pairs(incrementalOffsetList) do
            script = script..'\n'..key..' = 0'
        end

        for key,value in pairs(toggleOffsetList) do
            script = script..'\n'..key..' = \[\[Blank\]\]'
        end

        for key,value in pairs(checkboxOffsetList) do
            script = script..'\n'..key..' = {'
            for i,v in pairs(value['listVariables']) do
                if tonumber(v) then
                    script = script..'\n\t['..v..'] = '..'false'..','
                else
                    script = script..'\n\t[\"'..v..'\"] = '..'false'..','
                end
            end
            script = string.sub(script,1,-2)
            script = script..'\n}\n'
        end

        local offsetArray = {textOffsetList, inertOffsetList}
        for i,v in pairs(offsetArray) do
            for key,value in pairs(v) do
                script = script..'\n'..key..' = \[\[Blank\]\]'
            end
        end

        script = script..'\n\nfunction onLoad(save_state)\n\tself.setName("New Journal")\n\tself.setDescription(\''..characterSheetSource.getVar('uniqueID')..'\')\nend'

        obj.setLuaScript(script)
    end
end

function parseSave(content)
    local result = content:gsub("\n","\\n")
    return result:gsub("%'", "\\'")
    --return result
end

function returnColorTable(color)
    if color == true then return {['r']=0,['g']=0,['b']=0} end
    local tint = {
        ['Red']         = {0.856,0.1,0.094},
        ['Orange']      = {0.956,0.392,0.113},
        ['Yellow']      = {0.905,0.898,0.172},
        ['Green']       = {0.192,0.701,0.168},
        ['Blue']        = {0.118,0.53,1.0},
        ['Purple']      = {0.627,0.125,0.941},
        ['Black']       = {0,0,0},
        ['Grey']        = {0.84,0.84,0.84},
        ['White']       = {1,1,1},
        ['Pink']        = {1.0,0.3222451,1.0},
        ['Copper']      = {0.71,0.39,0.15},
        ['Silver']      = {0.75,0.75,0.75},
        ['Electrum']    = {0.8,0.81,0.6},
        ['Gold']        = {1.0,0.84,0.0},
        ['Platinum']    = {0.75,0.79,0.85},
    }
    return {['r']=tint[color][1],['g']=tint[color][2],['b']=tint[color][3]}
end

function array_sub(t1, t2)
  local t = {}
  local result = t2
  for i = 1, #t1 do
    t[t1[i]] = true;
  end
  for i = #t2, 1, -1 do
    if t[t2[i]] then
      table.remove(result, i);
    end
  end
  return result
end

function keyFromValue( t, value )
  for k,v in pairs(t) do
    if v==value then return k end
    end
  return nil
end

function contains(table, element)
  for _, value in pairs(table) do
    if value == element then
      return true
    end
  end
  return false
end

function getProficienciesString(color, tableName) -- Reads vars from the journal and creates a string of unicode circles based on the result.
    local str = ''
    local itemTable = CharacterJournals[color].getTable(tableName)
    for i,v in pairs(itemTable) do
        if itemTable[i] == true then
            str = str..string.char(9679)..'\n'
        else
            str = str..'\n'
        end
    end
    return str
end

function scrollUp(obj,color)
    local key = keyFromValue(playerInformation[color],obj)
    if playerInformation[color]['scrollbars'][key]['above'] ~= '' then
        local verifyCharacters = tool.call('getPageAccessor',{obj.getDescription()})
        if type(verifyCharacters) == 'table' then -- getPage() returns a table when it encounters a character that doesn't exist within the characterWidthTable.
            printToColor('Unrecognized character: "'..verifyCharacters[1]..'" in scrollbar notecard "'..obj.getName()..'"\nPlease delete it.',color,{1,0.2,0.2})
        else
            local newPage = string.reverse(tool.call('getPageAccessor',{string.reverse(playerInformation[color]['scrollbars'][key]['above'])}))
            if obj.getDescription() ~= '' then
                local i = string.len(newPage)
                local tempPage = tool.call('getPageAccessor',{tool.call('removeNewlineAccessor',{tool.call('removeNewlineAccessor',{newPage..'\n'..tool.call('preserveNewlineAccessor',{obj.getDescription()}),'Ending'}),'Beginning'})})
                local j = string.len(tempPage)
                if i < j then
                    newPage = tempPage
                    playerInformation[color]['scrollbars'][key]['above'] = tool.call('removeNewlineAccessor',{tool.call('removeNewlineAccessor',{tool.call('plainReplaceAccessor',{playerInformation[color]['scrollbars'][key]['above'],string.sub(newPage,1,i),''}),'Ending'}),'Beginning'})
                    playerInformation[color]['scrollbars'][key]['below'] = tool.call('removeNewlineAccessor',{tool.call('removeNewlineAccessor',{tool.call('plainReplaceAccessor',{tool.call('preserveNewlineAccessor',{obj.getDescription()}),tool.call('removeNewlineAccessor',{string.sub(newPage,i+1,j),'Beginning'}),''})..'\n'..playerInformation[color]['scrollbars'][key]['below'],'Beginning'}),'Ending'})
                else
                    playerInformation[color]['scrollbars'][key]['above'] = tool.call('removeNewlineAccessor',{tool.call('plainReplaceAccessor',{playerInformation[color]['scrollbars'][key]['above'],tool.call('removeNewlineAccessor',{tool.call('removeNewlineAccessor',{newPage,'Ending'}),'Beginning'}),''}),'Ending'})
                    playerInformation[color]['scrollbars'][key]['below'] = tool.call('removeNewlineAccessor',{tool.call('removeNewlineAccessor',{tool.call('preserveNewlineAccessor',{obj.getDescription()})..'\n'..playerInformation[color]['scrollbars'][key]['below'],'Ending'}),'Beginning'})
                end
            else
                playerInformation[color]['scrollbars'][key]['above'] = tool.call('removeNewlineAccessor',{tool.call('plainReplaceAccessor',{playerInformation[color]['scrollbars'][key]['above'],tool.call('removeNewlineAccessor',{tool.call('removeNewlineAccessor',{newPage,'Ending'}),'Beginning'}),''}),'Ending'})
            end
            obj.setDescription(tool.call('removeNewlineAccessor',{tool.call('removeNewlineAccessor',{newPage,'Ending'}),'Beginning'}))
            playerInformation[color]['scrollbars'][key]['starting'] = obj.getDescription()
        end
    end
end

function scrollDown(obj,color)
    local key = keyFromValue(playerInformation[color],obj)
    if obj.getDescription() ~= '' or playerInformation[color]['scrollbars'][key]['below'] ~= '' then
        local abovePage = tool.call('getPageAccessor',{tool.call('preserveNewlineAccessor',{obj.getDescription()})})
        local newPage
        if type(abovePage) == 'table' then -- getPage() returns a table when it encounters a character that doesn't exist within the characterWidthTable.
            printToColor('Unrecognized character: "'..abovePage[1]..'" in scrollbar notecard "'..obj.getName()..'"\nPlease delete it.',color,{1,0.2,0.2})
        else
            local tempPage = string.sub(tool.call('preserveNewlineAccessor',{obj.getDescription()}),string.len(abovePage)+1,-1)
            if tempPage ~= '' then
                newPage = tool.call('getPageAccessor',{tool.call('removeNewlineAccessor',{tool.call('removeNewlineAccessor',{tempPage..'\n'..playerInformation[color]['scrollbars'][key]['below'],'Ending'}),'Beginning'})})
                if type(newPage) == 'table' then -- getPage() returns a table when it encounters a character that doesn't exist within the characterWidthTable.
                    printToColor('Unrecognized character: "'..newPage[1]..'" in scrollbar notecard "'..obj.getName()..'"\nPlease delete it.',color,{1,0.2,0.2})
                    return 0
                end
                if string.len(newPage) > string.len(tempPage) then
                    tempPage = ''
                end
            else
                tempPage = ''
                newPage = tool.call('getPageAccessor',{tool.call('removeNewlineAccessor',{tool.call('removeNewlineAccessor',{playerInformation[color]['scrollbars'][key]['below'],'Ending'}),'Beginning'})})
            end
            playerInformation[color]['scrollbars'][key]['above'] = tool.call('removeNewlineAccessor',{playerInformation[color]['scrollbars'][key]['above']..'\n'..abovePage,'Beginning'})

            local extraLength1 = tool.call('getLinesAccessor',{tool.call('preserveNewlineAccessor',{obj.getDescription()})})
            local tempStartingText = tool.call('getLinesAccessor',{playerInformation[color]['scrollbars'][key]['starting']})
            local extraLength2 = extraLength1['lineCount'] - tempStartingText['lineCount']
            local extraLength3 = tool.call('getLinesAccessor',{playerInformation[color]['scrollbars'][key]['below']})
            local extraLength4 = tempStartingText['lineCount'] - extraLength2
            local extraLength5 = extraLength3[extraLength4]
            obj.setDescription(tool.call('removeNewlineAccessor',{tool.call('removeNewlineAccessor',{newPage,'Beginning'}),'Ending'}))
            playerInformation[color]['scrollbars'][key]['starting'] = obj.getDescription()
            if extraLength2 > 0 and extraLength4 <= extraLength3['lineCount'] and extraLength4 > 0 and extraLength5 ~= nil then
                playerInformation[color]['scrollbars'][key]['below'] = tool.call('removeNewlineAccessor',{string.sub(tempPage..playerInformation[color]['scrollbars'][key]['below'],extraLength5+1),'Beginning'})
            else
                if string.len(obj.getDescription()) ~= string.len(playerInformation[color]['scrollbars'][key]['below']) then
                    playerInformation[color]['scrollbars'][key]['below'] = tool.call('removeNewlineAccessor',{tool.call('removeNewlineAccessor',{string.sub(tempPage..playerInformation[color]['scrollbars'][key]['below'],string.len(obj.getDescription())+2),'Ending'}),'Beginning'})
                else
                    playerInformation[color]['scrollbars'][key]['below'] = ''
                end
            end
        end
    end
end

function getFullText(color,key) -- returns the complete string of data for a card.
    local fullText = playerInformation[color][key].getDescription()
    if playerInformation[color]['scrollbars'][key]['above'] ~= '' then
        fullText = playerInformation[color]['scrollbars'][key]['above']..'\n'..fullText
    end
    if playerInformation[color]['scrollbars'][key]['below'] ~= '' then
        fullText = fullText..'\n'..playerInformation[color]['scrollbars'][key]['below']
    end
    return fullText
end

-- getPage is in tools
-- getLines is in tools
-- removeNewline is in tools
-- preserveNewline is in tools
-- plainReplace is in tools


function print_r ( t )
    local print_r_cache={}
    local function sub_print_r(t,indent)
        if (print_r_cache[tostring(t)]) then
            print(indent.."*"..tostring(t))
        else
            print_r_cache[tostring(t)]=true
            if (type(t)=="table") then
                for pos,val in pairs(t) do
                    if (type(val)=="table") then
                        print(indent.."['"..pos.."\'] => "..tostring(t).." {")
                        sub_print_r(val,indent..string.rep(" ",string.len(pos)+8))
                        print(indent..string.rep(" ",string.len(pos)+6).."}")
                    elseif (type(val)=="string") then
                        print(indent.."['"..pos..'\'] => "'..val..'"')
                    else
                        print(indent.."['"..pos.."\'] => "..tostring(val))
                    end
                end
            else
                print(indent..tostring(t))
            end
        end
    end
    if (type(t)=="table") then
        print(tostring(t).." {")
        sub_print_r(t,"  ")
        print("}")
    else
        sub_print_r(t,"  ")
    end
    print()
end


function DEBUGPrintNotecardPos()
    print_r(playerInformation['purple']['Equipoment'].getPosition())
    for i=1,5 do
        print_r(playerInformation['purple']['Note'..i].getPosition())
    end
end
function DEBUGprintJournal()
    print_r(CharacterJournals)
end
function DEBUGprintPlayerInfo()
    print_r(playerInformation)
end

function getSeatedPlayersExcept(table)
    local result = getSeatedPlayers()
    return array_sub(table,result)
end
